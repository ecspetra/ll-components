"use strict";

var _util = _interopRequireDefault(require("util"));

var _stringifyValidator = _interopRequireDefault(require("../utils/stringifyValidator.js"));

var _toFunctionName = _interopRequireDefault(require("../utils/toFunctionName.js"));

var _index = _interopRequireDefault(require("../../lib/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var readme = ["---\nid: babel-types\ntitle: @babel/types\n---\n<!-- Do not modify! This file is automatically generated by\n  github.com/babel/babel/babel-types/scripts/generators/docs.js !-->\n\n> This module contains methods for building ASTs manually and for checking the types of AST nodes.\n\n## Install\n\n```sh\nnpm install --save-dev @babel/types\n```\n\n## API"];
var customTypes = {
  ClassMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  },
  Identifier: {
    name: "`string`"
  },
  MemberExpression: {
    property: "if computed then `Expression` else `Identifier`"
  },
  ObjectMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  },
  ObjectProperty: {
    key: "if computed then `Expression` else `Identifier | Literal`"
  },
  ClassPrivateMethod: {
    computed: "'false'"
  },
  ClassPrivateProperty: {
    computed: "'false'"
  }
};
var APIHistory = {
  ClassProperty: [["v7.6.0", "Supports `static`"]]
};

function formatHistory(historyItems) {
  var lines = historyItems.map(function (item) {
    return "| `" + item[0] + "` | " + item[1] + " |";
  });
  return ["<details>", "  <summary>History</summary>", "| Version | Changes |", "| --- | --- |"].concat(_toConsumableArray(lines), ["</details>"]);
}

function printAPIHistory(key, readme) {
  if (APIHistory[key]) {
    readme.push("");
    readme.push.apply(readme, _toConsumableArray(formatHistory(APIHistory[key])));
  }
}

function printNodeFields(key, readme) {
  if (Object.keys(_index["default"].NODE_FIELDS[key]).length > 0) {
    readme.push("");
    readme.push("AST Node `" + key + "` shape:");
    Object.keys(_index["default"].NODE_FIELDS[key]).sort(function (fieldA, fieldB) {
      var indexA = _index["default"].BUILDER_KEYS[key].indexOf(fieldA);

      var indexB = _index["default"].BUILDER_KEYS[key].indexOf(fieldB);

      if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    }).forEach(function (field) {
      var defaultValue = _index["default"].NODE_FIELDS[key][field]["default"];
      var fieldDescription = ["`" + field + "`"];
      var validator = _index["default"].NODE_FIELDS[key][field].validate;

      if (customTypes[key] && customTypes[key][field]) {
        fieldDescription.push(": ".concat(customTypes[key][field]));
      } else if (validator) {
        try {
          fieldDescription.push(": `" + (0, _stringifyValidator["default"])(validator, "") + "`");
        } catch (ex) {
          if (ex.code === "UNEXPECTED_VALIDATOR_TYPE") {
            console.log("Unrecognised validator type for " + key + "." + field);
            console.dir(ex.validator, {
              depth: 10,
              colors: true
            });
          }
        }
      }

      if (defaultValue !== null || _index["default"].NODE_FIELDS[key][field].optional) {
        fieldDescription.push(" (default: `" + _util["default"].inspect(defaultValue) + "`");

        if (_index["default"].BUILDER_KEYS[key].indexOf(field) < 0) {
          fieldDescription.push(", excluded from builder function");
        }

        fieldDescription.push(")");
      } else {
        fieldDescription.push(" (required)");
      }

      readme.push("- " + fieldDescription.join(""));
    });
  }
}

function printAliasKeys(key, readme) {
  if (_index["default"].ALIAS_KEYS[key] && _index["default"].ALIAS_KEYS[key].length) {
    readme.push("");
    readme.push("Aliases: " + _index["default"].ALIAS_KEYS[key].map(function (key) {
      return "[`" + key + "`](#" + key.toLowerCase() + ")";
    }).join(", "));
  }
}

readme.push("### Node Builders");
readme.push("");
Object.keys(_index["default"].BUILDER_KEYS).sort().forEach(function (key) {
  readme.push("#### " + (0, _toFunctionName["default"])(key));
  readme.push("");
  readme.push("```javascript");
  readme.push("t." + (0, _toFunctionName["default"])(key) + "(" + _index["default"].BUILDER_KEYS[key].join(", ") + ");");
  readme.push("```");
  printAPIHistory(key, readme);
  readme.push("");
  readme.push("See also `t.is" + key + "(node, opts)` and `t.assert" + key + "(node, opts)`.");
  printNodeFields(key, readme);
  printAliasKeys(key, readme);
  readme.push("");
  readme.push("---");
  readme.push("");
});

function generateMapAliasToNodeTypes() {
  var result = new Map();

  for (var _i = 0, _Object$keys = Object.keys(_index["default"].ALIAS_KEYS); _i < _Object$keys.length; _i++) {
    var nodeType = _Object$keys[_i];
    var aliases = _index["default"].ALIAS_KEYS[nodeType];
    if (!aliases) continue;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var alias = _step.value;

        if (!result.has(alias)) {
          result.set(alias, []);
        }

        var nodeTypes = result.get(alias);
        nodeTypes.push(nodeType);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return result;
}

var aliasDescriptions = {
  Binary: "A cover of BinaryExpression and LogicalExpression, which share the same AST shape.",
  Block: "Deprecated. Will be removed in Babel 8.",
  BlockParent: "A cover of AST nodes that start an execution context with new [LexicalEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `let` and `const` declarations.",
  Class: "A cover of ClassExpression and ClassDeclaration, which share the same AST shape.",
  CompletionStatement: "A statement that indicates the [completion records](https://tc39.es/ecma262/#sec-completion-record-specification-type). In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.",
  Conditional: "A cover of ConditionalExpression and IfStatement, which share the same AST shape.",
  Declaration: "A cover of any [Declaration](https://tc39.es/ecma262/#prod-Declaration)s.",
  EnumBody: "A cover of Flow enum bodies.",
  EnumMember: "A cover of Flow enum membors.",
  ExportDeclaration: "A cover of any [ExportDeclaration](https://tc39.es/ecma262/#prod-ExportDeclaration)s.",
  Expression: "A cover of any [Expression](https://tc39.es/ecma262/#sec-ecmascript-language-expressions)s.",
  ExpressionWrapper: "A wrapper of expression that does not have runtime semantics.",
  Flow: "A cover of AST nodes defined for Flow.",
  FlowBaseAnnotation: "A cover of primary Flow type annotations.",
  FlowDeclaration: "A cover of Flow declarations.",
  FlowPredicate: "A cover of Flow predicates.",
  FlowType: "A cover of Flow type annotations.",
  For: "A cover of [ForStatement](https://tc39.es/ecma262/#sec-for-statement)s and [ForXStatement](#forxstatement)s.",
  ForXStatement: "A cover of [ForInStatements and ForOfStatements](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements).",
  Function: "A cover of functions and [method](#method)s, the must have `body` and `params`. Note: `Function` is different to `FunctionParent`.",
  FunctionParent: "A cover of AST nodes that start an execution context with new [VariableEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `var` declarations. FunctionParent did not include `Program` since Babel 7.",
  Immutable: "A cover of immutable objects and JSX elements. An object is [immutable](https://tc39.es/ecma262/#immutable-prototype-exotic-object) if no other properties can be defined once created.",
  JSX: "A cover of AST nodes defined for [JSX](https://facebook.github.io/jsx/).",
  LVal: "A cover of left hand side expressions used in the `left` of assignment expressions and [ForXStatement](#forxstatement)s. ",
  Literal: "A cover of [Literal](https://tc39.es/ecma262/#sec-primary-expression-literals)s, [Regular Expression Literal](https://tc39.es/ecma262/#sec-primary-expression-regular-expression-literals)s and [Template Literal](https://tc39.es/ecma262/#sec-template-literals)s.",
  Loop: "A cover of loop statements.",
  Method: "A cover of object methods and class methods.",
  ModuleDeclaration: "A cover of ImportDeclaration and [ExportDeclaration](#exportdeclaration)",
  ModuleSpecifier: "A cover of import and export specifiers. Note: It is _not_ the [ModuleSpecifier](https://tc39.es/ecma262/#prod-ModuleSpecifier) defined in the spec.",
  ObjectMember: "A cover of [members](https://tc39.es/ecma262/#prod-PropertyDefinitionList) in an object literal.",
  Pattern: "A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern) except Identifiers.",
  PatternLike: "A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern)s. ",
  Private: "A cover of private class elements and private identifiers.",
  Property: "A cover of object properties and class properties.",
  Pureish: "A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.",
  Scopable: "A cover of [FunctionParent](#functionparent) and [BlockParent](#blockparent).",
  Statement: "A cover of any [Statement](https://tc39.es/ecma262/#prod-Statement)s.",
  TSBaseType: "A cover of primary TypeScript type annotations.",
  TSEntityName: "A cover of ts entities.",
  TSType: "A cover of TypeScript type annotations.",
  TSTypeElement: "A cover of TypeScript type declarations.",
  Terminatorless: "A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.",
  UnaryLike: "A cover of UnaryExpression and SpreadElement.",
  UserWhitespacable: "Deprecated. Will be removed in Babel 8.",
  While: "A cover of DoWhileStatement and WhileStatement, which share the same AST shape."
};
var mapAliasToNodeTypes = generateMapAliasToNodeTypes();
readme.push("### Aliases");
readme.push("");
var _iteratorNormalCompletion2 = true;
var _didIteratorError2 = false;
var _iteratorError2 = undefined;

try {
  for (var _iterator2 = _toConsumableArray(mapAliasToNodeTypes.keys()).sort()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    var alias = _step2.value;
    var nodeTypes = mapAliasToNodeTypes.get(alias);
    nodeTypes.sort();

    if (!(alias in aliasDescriptions)) {
      throw new Error('Missing alias descriptions of "' + alias + ", which covers " + nodeTypes.join(","));
    }

    readme.push("#### " + alias);
    readme.push("");
    readme.push(aliasDescriptions[alias]);
    readme.push("```javascript");
    readme.push("t.is" + alias + "(node);");
    readme.push("```");
    readme.push("");
    readme.push("Covered nodes: ");
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = nodeTypes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var nodeType = _step3.value;
        readme.push("- [`" + nodeType + "`](#" + nodeType.toLowerCase() + ")");
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    readme.push("");
  }
} catch (err) {
  _didIteratorError2 = true;
  _iteratorError2 = err;
} finally {
  try {
    if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
      _iterator2["return"]();
    }
  } finally {
    if (_didIteratorError2) {
      throw _iteratorError2;
    }
  }
}

process.stdout.write(readme.join("\n"));