'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, TokenType);

  this.label = void 0;
  this.keyword = void 0;
  this.beforeExpr = void 0;
  this.startsExpr = void 0;
  this.rightAssociative = void 0;
  this.isLoop = void 0;
  this.isAssign = void 0;
  this.prefix = void 0;
  this.postfix = void 0;
  this.binop = void 0;
  this.updateContext = void 0;
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop != null ? conf.binop : null;
  this.updateContext = null;
};

var keywords$1 = new Map();

function createKeyword(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.keyword = name;
  var token = new TokenType(name, options);
  keywords$1.set(name, token);
  return token;
}

function createBinop(name, binop) {
  return new TokenType(name, {
    beforeExpr: beforeExpr,
    binop: binop
  });
}

var types$1 = {
  num: new TokenType("num", {
    startsExpr: startsExpr
  }),
  bigint: new TokenType("bigint", {
    startsExpr: startsExpr
  }),
  decimal: new TokenType("decimal", {
    startsExpr: startsExpr
  }),
  regexp: new TokenType("regexp", {
    startsExpr: startsExpr
  }),
  string: new TokenType("string", {
    startsExpr: startsExpr
  }),
  name: new TokenType("name", {
    startsExpr: startsExpr
  }),
  privateName: new TokenType("#name", {
    startsExpr: startsExpr
  }),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketHashL: new TokenType("#[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketBarL: new TokenType("[|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketR: new TokenType("]"),
  bracketBarR: new TokenType("|]"),
  braceL: new TokenType("{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceBarL: new TokenType("{|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceHashL: new TokenType("#{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceR: new TokenType("}", {
    beforeExpr: beforeExpr
  }),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", {
    beforeExpr: beforeExpr
  }),
  semi: new TokenType(";", {
    beforeExpr: beforeExpr
  }),
  colon: new TokenType(":", {
    beforeExpr: beforeExpr
  }),
  doubleColon: new TokenType("::", {
    beforeExpr: beforeExpr
  }),
  dot: new TokenType("."),
  question: new TokenType("?", {
    beforeExpr: beforeExpr
  }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", {
    beforeExpr: beforeExpr
  }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", {
    beforeExpr: beforeExpr
  }),
  backQuote: new TokenType("`", {
    startsExpr: startsExpr
  }),
  dollarBraceL: new TokenType("${", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  at: new TokenType("@"),
  hash: new TokenType("#", {
    startsExpr: startsExpr
  }),
  interpreterDirective: new TokenType("#!..."),
  eq: new TokenType("=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  assign: new TokenType("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  slashAssign: new TokenType("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  moduloAssign: new TokenType("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  incDec: new TokenType("++/--", {
    prefix: prefix,
    postfix: postfix,
    startsExpr: startsExpr
  }),
  bang: new TokenType("!", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  tilde: new TokenType("~", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 1),
  logicalAND: createBinop("&&", 2),
  bitwiseOR: createBinop("|", 3),
  bitwiseXOR: createBinop("^", 4),
  bitwiseAND: createBinop("&", 5),
  equality: createBinop("==/!=/===/!==", 6),
  relational: createBinop("</>/<=/>=", 7),
  bitShift: createBinop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr: beforeExpr,
    binop: 9,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  modulo: new TokenType("%", {
    binop: 10,
    startsExpr: startsExpr
  }),
  star: new TokenType("*", {
    binop: 10
  }),
  slash: createBinop("/", 10),
  exponent: new TokenType("**", {
    beforeExpr: beforeExpr,
    binop: 11,
    rightAssociative: true
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr: beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr: beforeExpr
  }),
  _do: createKeyword("do", {
    isLoop: isLoop,
    beforeExpr: beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr: beforeExpr
  }),
  _finally: createKeyword("finally"),
  _for: createKeyword("for", {
    isLoop: isLoop
  }),
  _function: createKeyword("function", {
    startsExpr: startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr: beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _while: createKeyword("while", {
    isLoop: isLoop
  }),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr: startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr: startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr: startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr: beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr: startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr: startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr: startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr: startsExpr
  }),
  _in: createKeyword("in", {
    beforeExpr: beforeExpr,
    binop: 7
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr: beforeExpr,
    binop: 7
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  })
};
var lineBreak = /\r\n?|[\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var skipWhiteSpaceInLine = new RegExp("(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*", "y");
var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");

function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

var Position = function Position(line, col) {
  _classCallCheck(this, Position);

  this.line = void 0;
  this.column = void 0;
  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = void 0;
  this.end = void 0;
  this.filename = void 0;
  this.identifierName = void 0;
  this.start = start;
  this.end = end;
};

function getLineInfo(input, offset) {
  var line = 1;
  var lineStart = 0;
  var match;
  lineBreakG.lastIndex = 0;

  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }

  return new Position(line, offset - lineStart);
}

var BaseParser =
/*#__PURE__*/
function () {
  function BaseParser() {
    _classCallCheck(this, BaseParser);

    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  _createClass(BaseParser, [{
    key: "hasPlugin",
    value: function hasPlugin(name) {
      return this.plugins.has(name);
    }
  }, {
    key: "getPluginOption",
    value: function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }
  }]);

  return BaseParser;
}();

function setTrailingComments(node, comments) {
  if (node.trailingComments === undefined) {
    node.trailingComments = comments;
  } else {
    var _node$trailingComment;

    (_node$trailingComment = node.trailingComments).unshift.apply(_node$trailingComment, _toConsumableArray(comments));
  }
}

function setInnerComments(node, comments) {
  if (node.innerComments === undefined) {
    node.innerComments = comments;
  } else if (comments !== undefined) {
    var _node$innerComments;

    (_node$innerComments = node.innerComments).unshift.apply(_node$innerComments, _toConsumableArray(comments));
  }
}

function adjustInnerComments(node, elements, commentWS) {
  var lastElement = null;
  var i = elements.length;

  while (lastElement === null && i > 0) {
    lastElement = elements[--i];
  }

  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments(node, commentWS.comments);
  } else {
    setTrailingComments(lastElement, commentWS.comments);
  }
}

var CommentsParser =
/*#__PURE__*/
function (_BaseParser) {
  _inherits(CommentsParser, _BaseParser);

  function CommentsParser() {
    _classCallCheck(this, CommentsParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(CommentsParser).apply(this, arguments));
  }

  _createClass(CommentsParser, [{
    key: "addComment",
    value: function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.comments.push(comment);
    }
  }, {
    key: "processComment",
    value: function processComment(node) {
      var commentStack = this.state.commentStack;
      var commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      var i = commentStackLength - 1;
      var lastCommentWS = commentStack[i];

      if (lastCommentWS.start === node.end) {
        lastCommentWS.leadingNode = node;
        i--;
      }

      var nodeStart = node.start;

      for (; i >= 0; i--) {
        var commentWS = commentStack[i];
        var commentEnd = commentWS.end;

        if (commentEnd > nodeStart) {
          commentWS.containingNode = node;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node;
          }

          break;
        }
      }
    }
  }, {
    key: "finalizeComment",
    value: function finalizeComment(commentWS) {
      var comments = commentWS.comments;

      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }

        if (commentWS.trailingNode !== null) {
          commentWS.trailingNode.leadingComments = comments;
        }
      } else {
        var node = commentWS.containingNode,
            commentStart = commentWS.start;

        if (this.input.charCodeAt(commentStart - 1) === 44) {
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;

            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;

            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;

            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;

            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;

            default:
              {
                setInnerComments(node, comments);
              }
          }
        } else {
          setInnerComments(node, comments);
        }
      }
    }
  }, {
    key: "finalizeRemainingComments",
    value: function finalizeRemainingComments() {
      var commentStack = this.state.commentStack;

      for (var i = commentStack.length - 1; i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }

      this.state.commentStack = [];
    }
  }, {
    key: "resetPreviousNodeTrailingComments",
    value: function resetPreviousNodeTrailingComments(node) {
      var commentStack = this.state.commentStack;
      var length = commentStack.length;
      if (length === 0) return;
      var commentWS = commentStack[length - 1];

      if (commentWS.leadingNode === node) {
        commentWS.leadingNode = null;
      }
    }
  }]);

  return CommentsParser;
}(BaseParser);

var ErrorCodes = Object.freeze({
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
});
var ErrorMessages = makeErrorTemplates({
  AccessorIsGenerator: "A %0ter cannot be a generator.",
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accesor must not have any formal parameters.",
  BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: "'%0' require an initialization value.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: "Unsyntactic %0.",
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: "`import()` requires exactly %0.",
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: "Expected number in radix %0.",
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
  InvalidIdentifier: "Invalid identifier %0.",
  InvalidLhs: "Invalid left-hand side in %0.",
  InvalidLhsBinding: "Binding invalid left-hand side in %0.",
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: "Unexpected character '%0'.",
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: "Label '%0' is already declared.",
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
  ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
  ModuleExportUndefined: "Export '%0' is not defined.",
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
  PrivateNameRedeclaration: "Duplicate private name #%0.",
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  StaticPrototype: "Classes may not have static property named prototype.",
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: "Assigning to '%0' in strict mode.",
  StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: "Unexpected keyword '%0'.",
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
  UnexpectedReservedWord: "Unexpected reserved word '%0'.",
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: "Unexpected token '%0'.",
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  VarRedeclaration: "Identifier '%0' has already been declared.",
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, ErrorCodes.SyntaxError);
var SourceTypeModuleErrorMessages = makeErrorTemplates({
  ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
  ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'"
}, ErrorCodes.SourceTypeModuleError);

function makeErrorTemplates(messages, code) {
  var templates = {};
  Object.keys(messages).forEach(function (reasonCode) {
    templates[reasonCode] = Object.freeze({
      code: code,
      reasonCode: reasonCode,
      template: messages[reasonCode]
    });
  });
  return Object.freeze(templates);
}

var ParserError =
/*#__PURE__*/
function (_CommentsParser) {
  _inherits(ParserError, _CommentsParser);

  function ParserError() {
    _classCallCheck(this, ParserError);

    return _possibleConstructorReturn(this, _getPrototypeOf(ParserError).apply(this, arguments));
  }

  _createClass(ParserError, [{
    key: "getLocationForPosition",
    value: function getLocationForPosition(pos) {
      var loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    }
  }, {
    key: "raise",
    value: function raise(pos, _ref) {
      var code = _ref.code,
          reasonCode = _ref.reasonCode,
          template = _ref.template;

      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }

      return this.raiseWithData.apply(this, [pos, {
        code: code,
        reasonCode: reasonCode
      }, template].concat(params));
    }
  }, {
    key: "raiseOverwrite",
    value: function raiseOverwrite(pos, _ref2) {
      var code = _ref2.code,
          template = _ref2.template;

      for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        params[_key2 - 2] = arguments[_key2];
      }

      var loc = this.getLocationForPosition(pos);
      var message = template.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + " (".concat(loc.line, ":").concat(loc.column, ")");

      if (this.options.errorRecovery) {
        var errors = this.state.errors;

        for (var i = errors.length - 1; i >= 0; i--) {
          var error = errors[i];

          if (error.pos === pos) {
            return Object.assign(error, {
              message: message
            });
          } else if (error.pos < pos) {
            break;
          }
        }
      }

      return this._raise({
        code: code,
        loc: loc,
        pos: pos
      }, message);
    }
  }, {
    key: "raiseWithData",
    value: function raiseWithData(pos, data, errorTemplate) {
      for (var _len3 = arguments.length, params = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
        params[_key3 - 3] = arguments[_key3];
      }

      var loc = this.getLocationForPosition(pos);
      var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + " (".concat(loc.line, ":").concat(loc.column, ")");
      return this._raise(Object.assign({
        loc: loc,
        pos: pos
      }, data), message);
    }
  }, {
    key: "_raise",
    value: function _raise(errorContext, message) {
      var err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }
  }]);

  return ParserError;
}(CommentsParser);

var estree = function estree(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
      }

      _createClass(_class, [{
        key: "parseRegExpLiteral",
        value: function parseRegExpLiteral(_ref3) {
          var pattern = _ref3.pattern,
              flags = _ref3.flags;
          var regex = null;

          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {}

          var node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern: pattern,
            flags: flags
          };
          return node;
        }
      }, {
        key: "parseBigIntLiteral",
        value: function parseBigIntLiteral(value) {
          var bigInt;

          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }

          var node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
      }, {
        key: "parseDecimalLiteral",
        value: function parseDecimalLiteral(value) {
          var decimal = null;
          var node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
      }, {
        key: "estreeParseLiteral",
        value: function estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
      }, {
        key: "parseStringLiteral",
        value: function parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "parseNumericLiteral",
        value: function parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "parseNullLiteral",
        value: function parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
      }, {
        key: "parseBooleanLiteral",
        value: function parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
      }, {
        key: "directiveToStmt",
        value: function directiveToStmt(directive) {
          var directiveLiteral = directive.value;
          var stmt = this.startNodeAt(directive.start, directive.loc.start);
          var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.extra.expressionValue;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
        }
      }, {
        key: "initFunction",
        value: function initFunction(node, isAsync) {
          _get(_getPrototypeOf(_class.prototype), "initFunction", this).call(this, node, isAsync);

          node.expression = false;
        }
      }, {
        key: "checkDeclaration",
        value: function checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            _get(_getPrototypeOf(_class.prototype), "checkDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "getObjectOrClassMethodParams",
        value: function getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
      }, {
        key: "isValidDirective",
        value: function isValidDirective(stmt) {
          var _stmt$expression$extr;

          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
      }, {
        key: "stmtToDirective",
        value: function stmtToDirective(stmt) {
          var value = stmt.expression.value;

          var directive = _get(_getPrototypeOf(_class.prototype), "stmtToDirective", this).call(this, stmt);

          this.addExtra(directive.value, "expressionValue", value);
          return directive;
        }
      }, {
        key: "parseBlockBody",
        value: function parseBlockBody(node) {
          var _get2,
              _this2 = this;

          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          (_get2 = _get(_getPrototypeOf(_class.prototype), "parseBlockBody", this)).call.apply(_get2, [this, node].concat(args));

          var directiveStatements = node.directives.map(function (d) {
            return _this2.directiveToStmt(d);
          });
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }

          classBody.body.push(method);
        }
      }, {
        key: "parseMaybePrivateName",
        value: function parseMaybePrivateName() {
          var _get3;

          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var node = (_get3 = _get(_getPrototypeOf(_class.prototype), "parseMaybePrivateName", this)).call.apply(_get3, [this].concat(args));

          if (node.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
            return this.convertPrivateNameToPrivateIdentifier(node);
          }

          return node;
        }
      }, {
        key: "convertPrivateNameToPrivateIdentifier",
        value: function convertPrivateNameToPrivateIdentifier(node) {
          var name = _get(_getPrototypeOf(_class.prototype), "getPrivateNameSV", this).call(this, node);

          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
      }, {
        key: "isPrivateName",
        value: function isPrivateName(node) {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return _get(_getPrototypeOf(_class.prototype), "isPrivateName", this).call(this, node);
          }

          return node.type === "PrivateIdentifier";
        }
      }, {
        key: "getPrivateNameSV",
        value: function getPrivateNameSV(node) {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return _get(_getPrototypeOf(_class.prototype), "getPrivateNameSV", this).call(this, node);
          }

          return node.name;
        }
      }, {
        key: "parseLiteral",
        value: function parseLiteral(value, type) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseLiteral", this).call(this, value, type);

          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpression) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          _get(_getPrototypeOf(_class.prototype), "parseFunctionBody", this).call(this, node, allowExpression, isMethod);

          node.expression = node.body.type !== "BlockStatement";
        }
      }, {
        key: "parseMethod",
        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
          var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
          var funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = _get(_getPrototypeOf(_class.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;

          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }

          type = "MethodDefinition";
          return this.finishNode(node, type);
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty() {
          var _get4;

          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }

          var propertyNode = (_get4 = _get(_getPrototypeOf(_class.prototype), "parseClassProperty", this)).call.apply(_get4, [this].concat(args));

          if (this.getPluginOption("estree", "classFeatures")) {
            propertyNode.type = "PropertyDefinition";
          }

          return propertyNode;
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty() {
          var _get5;

          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }

          var propertyNode = (_get5 = _get(_getPrototypeOf(_class.prototype), "parseClassPrivateProperty", this)).call.apply(_get5, [this].concat(args));

          if (this.getPluginOption("estree", "classFeatures")) {
            propertyNode.type = "PropertyDefinition";
            propertyNode.computed = false;
          }

          return propertyNode;
        }
      }, {
        key: "parseObjectMethod",
        value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern, isAccessor);

          if (node) {
            node.type = "Property";
            if (node.kind === "method") node.kind = "init";
            node.shorthand = false;
          }

          return node;
        }
      }, {
        key: "parseObjectProperty",
        value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseObjectProperty", this).call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

          if (node) {
            node.kind = "init";
            node.type = "Property";
          }

          return node;
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }

          return _get(_getPrototypeOf(_class.prototype), "isAssignable", this).call(this, node, isBinding);
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (node != null && this.isObjectProperty(node)) {
            this.toAssignable(node.value, isLHS);
            return node;
          }

          return _get(_getPrototypeOf(_class.prototype), "toAssignable", this).call(this, node, isLHS);
        }
      }, {
        key: "toAssignableObjectExpressionProp",
        value: function toAssignableObjectExpressionProp(prop) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
          } else if (prop.method) {
            this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
          } else {
            var _get6;

            for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
              args[_key8 - 1] = arguments[_key8];
            }

            (_get6 = _get(_getPrototypeOf(_class.prototype), "toAssignableObjectExpressionProp", this)).call.apply(_get6, [this, prop].concat(args));
          }
        }
      }, {
        key: "finishCallExpression",
        value: function finishCallExpression(node, optional) {
          _get(_getPrototypeOf(_class.prototype), "finishCallExpression", this).call(this, node, optional);

          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];

            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;

              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }

            delete node.arguments;
            delete node.callee;
          }

          return node;
        }
      }, {
        key: "toReferencedArguments",
        value: function toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }

          _get(_getPrototypeOf(_class.prototype), "toReferencedArguments", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          _get(_getPrototypeOf(_class.prototype), "parseExport", this).call(this, node);

          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;

            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }

              break;
          }

          return node;
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var node = _get(_getPrototypeOf(_class.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, state);

          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }

            if (state.stop) {
              var chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }

          return node;
        }
      }, {
        key: "hasPropertyAsPrivateName",
        value: function hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }

          return _get(_getPrototypeOf(_class.prototype), "hasPropertyAsPrivateName", this).call(this, node);
        }
      }, {
        key: "isOptionalChain",
        value: function isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
      }, {
        key: "isObjectProperty",
        value: function isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
      }, {
        key: "isObjectMethod",
        value: function isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
      }]);

      return _class;
    }(superClass)
  );
};

var TokContext = function TokContext(token, preserveSpace) {
  _classCallCheck(this, TokContext);

  this.token = void 0;
  this.preserveSpace = void 0;
  this.token = token;
  this.preserveSpace = !!preserveSpace;
};

var types = {
  brace: new TokContext("{"),
  template: new TokContext("`", true)
};

types$1.braceR.updateContext = function (context) {
  context.pop();
};

types$1.braceL.updateContext = types$1.braceHashL.updateContext = types$1.dollarBraceL.updateContext = function (context) {
  context.push(types.brace);
};

types$1.backQuote.updateContext = function (context) {
  if (context[context.length - 1] === types.template) {
    context.pop();
  } else {
    context.push(types.template);
  }
};

var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

var reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}

function isIteratorStart(current, next) {
  return current === 64 && next === 64;
}

var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

function canBeReservedWord(word) {
  return reservedWordLikeSet.has(word);
}

var SCOPE_OTHER = 0,
    SCOPE_PROGRAM = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ARROW = 4,
    SCOPE_SIMPLE_CATCH = 8,
    SCOPE_SUPER = 16,
    SCOPE_DIRECT_SUPER = 32,
    SCOPE_CLASS = 64,
    SCOPE_STATIC_BLOCK = 128,
    SCOPE_TS_MODULE = 256,
    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
var BIND_KIND_VALUE = 1,
    BIND_KIND_TYPE = 2,
    BIND_SCOPE_VAR = 4,
    BIND_SCOPE_LEXICAL = 8,
    BIND_SCOPE_FUNCTION = 16,
    BIND_FLAGS_NONE = 64,
    BIND_FLAGS_CLASS = 128,
    BIND_FLAGS_TS_ENUM = 256,
    BIND_FLAGS_TS_CONST_ENUM = 512,
    BIND_FLAGS_TS_EXPORT_ONLY = 1024,
    BIND_FLAGS_FLOW_DECLARE_FN = 2048;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
    BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
var CLASS_ELEMENT_FLAG_STATIC = 4,
    CLASS_ELEMENT_KIND_GETTER = 2,
    CLASS_ELEMENT_KIND_SETTER = 1,
    CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
    CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
    CLASS_ELEMENT_OTHER = 0;

var Scope = function Scope(flags) {
  _classCallCheck(this, Scope);

  this["var"] = new Set();
  this.lexical = new Set();
  this.functions = new Set();
  this.flags = flags;
};

var ScopeHandler =
/*#__PURE__*/
function () {
  function ScopeHandler(raise, inModule) {
    _classCallCheck(this, ScopeHandler);

    this.scopeStack = [];
    this.undefinedExports = new Map();
    this.undefinedPrivateNames = new Map();
    this.raise = raise;
    this.inModule = inModule;
  }

  _createClass(ScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new Scope(flags);
    }
  }, {
    key: "enter",
    value: function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
  }, {
    key: "exit",
    value: function exit() {
      this.scopeStack.pop();
    }
  }, {
    key: "treatFunctionsAsVarInScope",
    value: function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope["var"].add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    }
  }, {
    key: "maybeExportDefined",
    value: function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    }
  }, {
    key: "checkRedeclarationInScope",
    value: function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope["var"].has(name);
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope["var"].has(name);
      }

      return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      var name = id.name;
      var topLevelScope = this.scopeStack[0];

      if (!topLevelScope.lexical.has(name) && !topLevelScope["var"].has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.start);
      }
    }
  }, {
    key: "currentScope",
    value: function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
  }, {
    key: "currentVarScopeFlags",
    value: function currentVarScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & SCOPE_VAR) {
          return flags;
        }
      }
    }
  }, {
    key: "currentThisScopeFlags",
    value: function currentThisScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
          return flags;
        }
      }
    }
  }, {
    key: "inFunction",
    get: function get() {
      return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "allowSuper",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }
  }, {
    key: "allowDirectSuper",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }
  }, {
    key: "inClass",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }
  }, {
    key: "inClassAndNotInNonArrowFunction",
    get: function get() {
      var flags = this.currentThisScopeFlags();
      return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }
  }, {
    key: "inStaticBlock",
    get: function get() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & SCOPE_STATIC_BLOCK) {
          return true;
        }

        if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
          return false;
        }
      }
    }
  }, {
    key: "inNonArrowFunction",
    get: function get() {
      return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: "treatFunctionsAsVar",
    get: function get() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
  }]);

  return ScopeHandler;
}();

var FlowScope =
/*#__PURE__*/
function (_Scope) {
  _inherits(FlowScope, _Scope);

  function FlowScope() {
    var _getPrototypeOf2;

    var _this3;

    _classCallCheck(this, FlowScope);

    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    _this3 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FlowScope)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this3.declareFunctions = new Set();
    return _this3;
  }

  return FlowScope;
}(Scope);

var FlowScopeHandler =
/*#__PURE__*/
function (_ScopeHandler) {
  _inherits(FlowScopeHandler, _ScopeHandler);

  function FlowScopeHandler() {
    _classCallCheck(this, FlowScopeHandler);

    return _possibleConstructorReturn(this, _getPrototypeOf(FlowScopeHandler).apply(this, arguments));
  }

  _createClass(FlowScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new FlowScope(flags);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }

      _get(_getPrototypeOf(FlowScopeHandler.prototype), "declareName", this).apply(this, arguments);
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (_get(_getPrototypeOf(FlowScopeHandler.prototype), "isRedeclaredInScope", this).apply(this, arguments)) return true;

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }

      return false;
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        _get(_getPrototypeOf(FlowScopeHandler.prototype), "checkLocalExport", this).call(this, id);
      }
    }
  }]);

  return FlowScopeHandler;
}(ScopeHandler);

var State =
/*#__PURE__*/
function () {
  function State() {
    _classCallCheck(this, State);

    this.strict = void 0;
    this.curLine = void 0;
    this.startLoc = void 0;
    this.endLoc = void 0;
    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.maybeInArrowParameters = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.inPropertyName = false;
    this.hasFlowComment = false;
    this.isAmbientContext = false;
    this.inAbstractClass = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.labels = [];
    this.decoratorStack = [[]];
    this.comments = [];
    this.commentStack = [];
    this.pos = 0;
    this.lineStart = 0;
    this.type = types$1.eof;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.lastTokEnd = 0;
    this.context = [types.brace];
    this.exprAllowed = true;
    this.containsEsc = false;
    this.strictErrors = new Map();
    this.tokensLength = 0;
  }

  _createClass(State, [{
    key: "init",
    value: function init(options) {
      this.strict = options.strictMode === false ? false : options.strictMode === true ? true : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }
  }, {
    key: "curPosition",
    value: function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  }, {
    key: "clone",
    value: function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }
  }]);

  return State;
}();

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};

var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
var forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
var allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.bin), [50, 51, 52, 53, 54, 55]);
allowedNumericSeparatorSiblings.dec = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.oct), [56, 57]);
allowedNumericSeparatorSiblings.hex = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.dec), [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);

var Token = function Token(state) {
  _classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

var Tokenizer =
/*#__PURE__*/
function (_ParserError) {
  _inherits(Tokenizer, _ParserError);

  function Tokenizer(options, input) {
    var _this4;

    _classCallCheck(this, Tokenizer);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Tokenizer).call(this));
    _this4.isLookahead = void 0;
    _this4.tokens = [];
    _this4.state = new State();

    _this4.state.init(options);

    _this4.input = input;
    _this4.length = input.length;
    _this4.isLookahead = false;
    return _this4;
  }

  _createClass(Tokenizer, [{
    key: "pushToken",
    value: function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
  }, {
    key: "next",
    value: function next() {
      this.checkKeywordEscapes();

      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
  }, {
    key: "eat",
    value: function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "match",
    value: function match(type) {
      return this.state.type === type;
    }
  }, {
    key: "createLookaheadState",
    value: function createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        lastTokEnd: state.end,
        context: [this.curContext()],
        inType: state.inType
      };
    }
  }, {
    key: "lookahead",
    value: function lookahead() {
      var old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    }
  }, {
    key: "nextTokenStart",
    value: function nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
  }, {
    key: "nextTokenStartSince",
    value: function nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
  }, {
    key: "lookaheadCharCode",
    value: function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
  }, {
    key: "codePointAtPos",
    value: function codePointAtPos(pos) {
      var cp = this.input.charCodeAt(pos);

      if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
        var trail = this.input.charCodeAt(pos);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      return cp;
    }
  }, {
    key: "setStrict",
    value: function setStrict(strict) {
      var _this5 = this;

      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach(function (message, pos) {
          return _this5.raise(pos, message);
        });
        this.state.strictErrors.clear();
      }
    }
  }, {
    key: "curContext",
    value: function curContext() {
      return this.state.context[this.state.context.length - 1];
    }
  }, {
    key: "nextToken",
    value: function nextToken() {
      var curContext = this.curContext();
      if (!curContext.preserveSpace) this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types$1.eof);
        return;
      }

      if (curContext === types.template) {
        this.readTmplToken();
      } else {
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
    }
  }, {
    key: "skipBlockComment",
    value: function skipBlockComment() {
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", start + 2);
      if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start + 2;

      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }

      if (this.isLookahead) return;
      var comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start: start,
        end: end + 2,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens) this.pushToken(comment);
      return comment;
    }
  }, {
    key: "skipLineComment",
    value: function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      var end = this.state.pos;
      var value = this.input.slice(start + startSkip, end);
      var comment = {
        type: "CommentLine",
        value: value,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens) this.pushToken(comment);
      return comment;
    }
  }, {
    key: "skipSpace",
    value: function skipSpace() {
      var spaceStart = this.state.pos;
      var comments = [];

      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                {
                  var comment = this.skipBlockComment();

                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }

                  break;
                }

              case 47:
                {
                  var _comment = this.skipLineComment(2);

                  if (_comment !== undefined) {
                    this.addComment(_comment);
                    if (this.options.attachComment) comments.push(_comment);
                  }

                  break;
                }

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else if (ch === 45 && !this.inModule) {
              var pos = this.state.pos;

              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                var _comment2 = this.skipLineComment(3);

                if (_comment2 !== undefined) {
                  this.addComment(_comment2);
                  if (this.options.attachComment) comments.push(_comment2);
                }
              } else {
                break loop;
              }
            } else if (ch === 60 && !this.inModule) {
              var _pos = this.state.pos;

              if (this.input.charCodeAt(_pos + 1) === 33 && this.input.charCodeAt(_pos + 2) === 45 && this.input.charCodeAt(_pos + 3) === 45) {
                var _comment3 = this.skipLineComment(4);

                if (_comment3 !== undefined) {
                  this.addComment(_comment3);
                  if (this.options.attachComment) comments.push(_comment3);
                }
              } else {
                break loop;
              }
            } else {
              break loop;
            }

        }
      }

      if (comments.length > 0) {
        var end = this.state.pos;
        var CommentWhitespace = {
          start: spaceStart,
          end: end,
          comments: comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(CommentWhitespace);
      }
    }
  }, {
    key: "finishToken",
    value: function finishToken(type, val) {
      this.state.end = this.state.pos;
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;

      if (!this.isLookahead) {
        this.state.endLoc = this.state.curPosition();
        this.updateContext(prevType);
      }
    }
  }, {
    key: "readToken_numberSign",
    value: function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.codePointAtPos(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }

        this.state.pos += 2;

        if (next === 123) {
          this.finishToken(types$1.braceHashL);
        } else {
          this.finishToken(types$1.bracketHashL);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1());
      } else {
        this.finishOp(types$1.hash, 1);
      }
    }
  }, {
    key: "readToken_dot",
    value: function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types$1.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.dot);
      }
    }
  }, {
    key: "readToken_slash",
    value: function readToken_slash() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.slashAssign, 2);
      } else {
        this.finishOp(types$1.slash, 1);
      }
    }
  }, {
    key: "readToken_interpreter",
    value: function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types$1.interpreterDirective, value);
      return true;
    }
  }, {
    key: "readToken_mult_modulo",
    value: function readToken_mult_modulo(code) {
      var type = code === 42 ? types$1.star : types$1.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types$1.exponent;
      }

      if (next === 61 && !this.state.inType) {
        width++;
        type = code === 37 ? types$1.moduloAssign : types$1.assign;
      }

      this.finishOp(type, width);
    }
  }, {
    key: "readToken_pipe_amp",
    value: function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types$1.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.braceBarR);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.bracketBarR);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    }
  }, {
    key: "readToken_caret",
    value: function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.bitwiseXOR, 1);
      }
    }
  }, {
    key: "readToken_plus_min",
    value: function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        this.finishOp(types$1.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.plusMin, 1);
      }
    }
  }, {
    key: "readToken_lt_gt",
    value: function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types$1.assign, size + 1);
          return;
        }

        this.finishOp(types$1.bitShift, size);
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types$1.relational, size);
    }
  }, {
    key: "readToken_eq_excl",
    value: function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types$1.arrow);
        return;
      }

      this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
    }
  }, {
    key: "readToken_question",
    value: function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(types$1.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types$1.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.question);
      }
    }
  }, {
    key: "getTokenFromCode",
    value: function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types$1.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types$1.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types$1.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types$1.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.bracketBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types$1.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.braceBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types$1.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types$1.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types$1.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types$1.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types$1.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord(code);
            return;
          }

      }

      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    }
  }, {
    key: "finishOp",
    value: function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
  }, {
    key: "readRegexp",
    value: function readRegexp() {
      var start = this.state.start + 1;
      var escaped, inClass;
      var pos = this.state.pos;

      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        var ch = this.input.charCodeAt(pos);

        if (isNewLine(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }

          escaped = ch === 92;
        }
      }

      var content = this.input.slice(start, pos);
      ++pos;
      var mods = "";

      while (pos < this.length) {
        var cp = this.codePointAtPos(pos);

        var _char = String.fromCharCode(cp);

        if (VALID_REGEX_FLAGS.has(cp)) {
          if (mods.includes(_char)) {
            this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++pos;
        mods += _char;
      }

      this.state.pos = pos;
      this.finishToken(types$1.regexp, {
        pattern: content,
        flags: mods
      });
    }
  }, {
    key: "readInt",
    value: function readInt(radix, len, forceLen) {
      var allowNumSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (code === 95) {
          var prev = this.input.charCodeAt(this.state.pos - 1);
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    }
  }, {
    key: "readRadixNumber",
    value: function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types$1.bigint, str);
        return;
      }

      this.finishToken(types$1.num, val);
    }
  }, {
    key: "readNumber",
    value: function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isDecimal = false;
      var hasExponent = false;
      var isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        var integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

        if (!this.state.strict) {
          var underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(types$1.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types$1.decimal, str);
        return;
      }

      var val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types$1.num, val);
    }
  }, {
    key: "readCodePoint",
    value: function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }
  }, {
    key: "readString",
    value: function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types$1.string, out);
    }
  }, {
    key: "readTmplToken",
    value: function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types$1.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types$1.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types$1.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types$1.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }
  }, {
    key: "recordStrictModeErrors",
    value: function recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    }
  }, {
    key: "readEscapedChar",
    value: function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);

            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\x0B";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var codePos = this.state.pos - 1;
            var match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            var octalStr = match[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }
  }, {
    key: "readHexChar",
    value: function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    }
  }, {
    key: "readWord1",
    value: function readWord1(firstCode) {
      this.state.containsEsc = false;
      var word = "";
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 0xffff ? 1 : 2;
      }

      while (this.state.pos < this.length) {
        var ch = this.codePointAtPos(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            chunkStart = this.state.pos - 1;
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }
  }, {
    key: "readWord",
    value: function readWord(firstCode) {
      var word = this.readWord1(firstCode);
      var type = keywords$1.get(word) || types$1.name;
      this.finishToken(type, word);
    }
  }, {
    key: "checkKeywordEscapes",
    value: function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    }
  }, {
    key: "updateContext",
    value: function updateContext(prevType) {
      var _this$state$type$upda, _this$state$type;

      (_this$state$type$upda = (_this$state$type = this.state.type).updateContext) == null ? void 0 : _this$state$type$upda.call(_this$state$type, this.state.context);
    }
  }]);

  return Tokenizer;
}(ParserError);

var ClassScope = function ClassScope() {
  _classCallCheck(this, ClassScope);

  this.privateNames = new Set();
  this.loneAccessors = new Map();
  this.undefinedPrivateNames = new Map();
};

var ClassScopeHandler =
/*#__PURE__*/
function () {
  function ClassScopeHandler(raise) {
    _classCallCheck(this, ClassScopeHandler);

    this.stack = [];
    this.undefinedPrivateNames = new Map();
    this.raise = raise;
  }

  _createClass(ClassScopeHandler, [{
    key: "current",
    value: function current() {
      return this.stack[this.stack.length - 1];
    }
  }, {
    key: "enter",
    value: function enter() {
      this.stack.push(new ClassScope());
    }
  }, {
    key: "exit",
    value: function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();

      for (var _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {
        var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),
            name = _Array$from$_i[0],
            pos = _Array$from$_i[1];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    }
  }, {
    key: "declarePrivateName",
    value: function declarePrivateName(name, elementType, pos) {
      var classScope = this.current();
      var redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        var accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors["delete"](name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames["delete"](name);
    }
  }, {
    key: "usePrivateName",
    value: function usePrivateName(name, pos) {
      var classScope;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.stack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          classScope = _step.value;
          if (classScope.privateNames.has(name)) return;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }
  }]);

  return ClassScopeHandler;
}();

var kExpression = 0,
    kMaybeArrowParameterDeclaration = 1,
    kMaybeAsyncArrowParameterDeclaration = 2,
    kParameterDeclaration = 3;

var ExpressionScope =
/*#__PURE__*/
function () {
  function ExpressionScope() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : kExpression;

    _classCallCheck(this, ExpressionScope);

    this.type = void 0;
    this.type = type;
  }

  _createClass(ExpressionScope, [{
    key: "canBeArrowParameterDeclaration",
    value: function canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }
  }, {
    key: "isCertainlyParameterDeclaration",
    value: function isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    }
  }]);

  return ExpressionScope;
}();

var ArrowHeadParsingScope =
/*#__PURE__*/
function (_ExpressionScope) {
  _inherits(ArrowHeadParsingScope, _ExpressionScope);

  function ArrowHeadParsingScope(type) {
    var _this6;

    _classCallCheck(this, ArrowHeadParsingScope);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ArrowHeadParsingScope).call(this, type));
    _this6.errors = new Map();
    return _this6;
  }

  _createClass(ArrowHeadParsingScope, [{
    key: "recordDeclarationError",
    value: function recordDeclarationError(pos, template) {
      this.errors.set(pos, template);
    }
  }, {
    key: "clearDeclarationError",
    value: function clearDeclarationError(pos) {
      this.errors["delete"](pos);
    }
  }, {
    key: "iterateErrors",
    value: function iterateErrors(iterator) {
      this.errors.forEach(iterator);
    }
  }]);

  return ArrowHeadParsingScope;
}(ExpressionScope);

var ExpressionScopeHandler =
/*#__PURE__*/
function () {
  function ExpressionScopeHandler(raise) {
    _classCallCheck(this, ExpressionScopeHandler);

    this.stack = [new ExpressionScope()];
    this.raise = raise;
  }

  _createClass(ExpressionScopeHandler, [{
    key: "enter",
    value: function enter(scope) {
      this.stack.push(scope);
    }
  }, {
    key: "exit",
    value: function exit() {
      this.stack.pop();
    }
  }, {
    key: "recordParameterInitializerError",
    value: function recordParameterInitializerError(pos, template) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, template);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.raise(pos, template);
    }
  }, {
    key: "recordParenthesizedIdentifierError",
    value: function recordParenthesizedIdentifierError(pos, template) {
      var stack = this.stack;
      var scope = stack[stack.length - 1];

      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, template);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, template);
      } else {
        return;
      }
    }
  }, {
    key: "recordAsyncArrowParametersError",
    value: function recordAsyncArrowParametersError(pos, template) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, template);
        }

        scope = stack[--i];
      }
    }
  }, {
    key: "validateAsPattern",
    value: function validateAsPattern() {
      var _this7 = this;

      var stack = this.stack;
      var currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(function (template, pos) {
        _this7.raise(pos, template);

        var i = stack.length - 2;
        var scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    }
  }]);

  return ExpressionScopeHandler;
}();

function newParameterDeclarationScope() {
  return new ExpressionScope(kParameterDeclaration);
}

function newArrowHeadScope() {
  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
}

function newAsyncArrowScope() {
  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
}

function newExpressionScope() {
  return new ExpressionScope();
}

var PARAM = 0,
    PARAM_YIELD = 1,
    PARAM_AWAIT = 2,
    PARAM_RETURN = 4,
    PARAM_IN = 8;

var ProductionParameterHandler =
/*#__PURE__*/
function () {
  function ProductionParameterHandler() {
    _classCallCheck(this, ProductionParameterHandler);

    this.stacks = [];
  }

  _createClass(ProductionParameterHandler, [{
    key: "enter",
    value: function enter(flags) {
      this.stacks.push(flags);
    }
  }, {
    key: "exit",
    value: function exit() {
      this.stacks.pop();
    }
  }, {
    key: "currentFlags",
    value: function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
  }, {
    key: "hasAwait",
    get: function get() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }
  }, {
    key: "hasYield",
    get: function get() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }
  }, {
    key: "hasReturn",
    get: function get() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }
  }, {
    key: "hasIn",
    get: function get() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }
  }]);

  return ProductionParameterHandler;
}();

function functionFlags(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}

var UtilParser =
/*#__PURE__*/
function (_Tokenizer) {
  _inherits(UtilParser, _Tokenizer);

  function UtilParser() {
    _classCallCheck(this, UtilParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(UtilParser).apply(this, arguments));
  }

  _createClass(UtilParser, [{
    key: "addExtra",
    value: function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    }
  }, {
    key: "isRelational",
    value: function isRelational(op) {
      return this.match(types$1.relational) && this.state.value === op;
    }
  }, {
    key: "expectRelational",
    value: function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types$1.relational);
      }
    }
  }, {
    key: "isContextual",
    value: function isContextual(name) {
      return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
    }
  }, {
    key: "isUnparsedContextual",
    value: function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;

      if (this.input.slice(nameStart, nameEnd) === name) {
        var nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
      }

      return false;
    }
  }, {
    key: "isLookaheadContextual",
    value: function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
  }, {
    key: "eatContextual",
    value: function eatContextual(name) {
      return this.isContextual(name) && this.eat(types$1.name);
    }
  }, {
    key: "expectContextual",
    value: function expectContextual(name, template) {
      if (!this.eatContextual(name)) this.unexpected(null, template);
    }
  }, {
    key: "canInsertSemicolon",
    value: function canInsertSemicolon() {
      return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
    }
  }, {
    key: "hasPrecedingLineBreak",
    value: function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
  }, {
    key: "hasFollowingLineBreak",
    value: function hasFollowingLineBreak() {
      skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
      return skipWhiteSpaceToLineBreak.test(this.input);
    }
  }, {
    key: "isLineTerminator",
    value: function isLineTerminator() {
      return this.eat(types$1.semi) || this.canInsertSemicolon();
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      var allowAsi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi)) return;
      this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    }
  }, {
    key: "expect",
    value: function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
  }, {
    key: "assertNoSpace",
    value: function assertNoSpace() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected space.";

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedSpace",
          template: message
        });
      }
    }
  }, {
    key: "unexpected",
    value: function unexpected(pos) {
      var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        code: ErrorCodes.SyntaxError,
        reasonCode: "UnexpectedToken",
        template: "Unexpected token"
      };

      if (messageOrType instanceof TokenType) {
        messageOrType = {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: "Unexpected token, expected \"".concat(messageOrType.label, "\"")
        };
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }
  }, {
    key: "expectPlugin",
    value: function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, "This experimental syntax requires enabling the parser plugin: '".concat(name, "'"));
      }

      return true;
    }
  }, {
    key: "expectOnePlugin",
    value: function expectOnePlugin(names, pos) {
      var _this8 = this;

      if (!names.some(function (n) {
        return _this8.hasPlugin(n);
      })) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(names.join(", "), "'"));
      }
    }
  }, {
    key: "tryParse",
    value: function tryParse(fn) {
      var oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();
      var abortSignal = {
        node: null
      };

      try {
        var node = fn(function () {
          var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    }
  }, {
    key: "checkExpressionErrors",
    value: function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssign = refExpressionErrors.shorthandAssign,
          doubleProto = refExpressionErrors.doubleProto,
          optionalParameters = refExpressionErrors.optionalParameters;

      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
      }

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }

      if (optionalParameters >= 0) {
        this.unexpected(optionalParameters);
      }
    }
  }, {
    key: "isLiteralPropertyName",
    value: function isLiteralPropertyName() {
      return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
    }
  }, {
    key: "isPrivateName",
    value: function isPrivateName(node) {
      return node.type === "PrivateName";
    }
  }, {
    key: "getPrivateNameSV",
    value: function getPrivateNameSV(node) {
      return node.id.name;
    }
  }, {
    key: "hasPropertyAsPrivateName",
    value: function hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
  }, {
    key: "isOptionalChain",
    value: function isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    }
  }, {
    key: "isObjectProperty",
    value: function isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }
  }, {
    key: "isObjectMethod",
    value: function isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }
  }, {
    key: "initializeScopes",
    value: function initializeScopes() {
      var _this9 = this;

      var inModule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.sourceType === "module";
      var oldLabels = this.state.labels;
      this.state.labels = [];
      var oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      var oldInModule = this.inModule;
      this.inModule = inModule;
      var oldScope = this.scope;
      var ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
      var oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      var oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      var oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
      return function () {
        _this9.state.labels = oldLabels;
        _this9.exportedIdentifiers = oldExportedIdentifiers;
        _this9.inModule = oldInModule;
        _this9.scope = oldScope;
        _this9.prodParam = oldProdParam;
        _this9.classScope = oldClassScope;
        _this9.expressionScope = oldExpressionScope;
      };
    }
  }, {
    key: "enterInitialScopes",
    value: function enterInitialScopes() {
      var paramFlags = PARAM;

      if (this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    }
  }]);

  return UtilParser;
}(Tokenizer);

var ExpressionErrors = function ExpressionErrors() {
  _classCallCheck(this, ExpressionErrors);

  this.shorthandAssign = -1;
  this.doubleProto = -1;
  this.optionalParameters = -1;
};

var Node = function Node(parser, pos, loc) {
  _classCallCheck(this, Node);

  this.type = "";
  this.start = pos;
  this.end = 0;
  this.loc = new SourceLocation(loc);
  if (parser != null && parser.options.ranges) this.range = [pos, 0];
  if (parser != null && parser.filename) this.loc.filename = parser.filename;
};

var NodePrototype = Node.prototype;
{
  NodePrototype.__clone = function () {
    var newNode = new Node();
    var keys = Object.keys(this);

    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];

      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
        newNode[key] = this[key];
      }
    }

    return newNode;
  };
}

function clonePlaceholder(node) {
  return cloneIdentifier(node);
}

function cloneIdentifier(node) {
  var type = node.type,
      start = node.start,
      end = node.end,
      loc = node.loc,
      range = node.range,
      extra = node.extra,
      name = node.name;
  var cloned = Object.create(NodePrototype);
  cloned.type = type;
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range;
  cloned.extra = extra;
  cloned.name = name;

  if (type === "Placeholder") {
    cloned.expectedNode = node.expectedNode;
  }

  return cloned;
}

function cloneStringLiteral(node) {
  var type = node.type,
      start = node.start,
      end = node.end,
      loc = node.loc,
      range = node.range,
      extra = node.extra;

  if (type === "Placeholder") {
    return clonePlaceholder(node);
  }

  var cloned = Object.create(NodePrototype);
  cloned.type = "StringLiteral";
  cloned.start = start;
  cloned.end = end;
  cloned.loc = loc;
  cloned.range = range;
  cloned.extra = extra;
  cloned.value = node.value;
  return cloned;
}

var NodeUtils =
/*#__PURE__*/
function (_UtilParser) {
  _inherits(NodeUtils, _UtilParser);

  function NodeUtils() {
    _classCallCheck(this, NodeUtils);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeUtils).apply(this, arguments));
  }

  _createClass(NodeUtils, [{
    key: "startNode",
    value: function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
  }, {
    key: "startNodeAt",
    value: function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
  }, {
    key: "startNodeAtNode",
    value: function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
  }, {
    key: "finishNode",
    value: function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
  }, {
    key: "finishNodeAt",
    value: function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      if (this.options.attachComment) this.processComment(node);
      return node;
    }
  }, {
    key: "resetStartLocation",
    value: function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }
  }, {
    key: "resetEndLocation",
    value: function resetEndLocation(node) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEnd;
      var endLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.lastTokEndLoc;
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }
  }, {
    key: "resetStartLocationFromNode",
    value: function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  }]);

  return NodeUtils;
}(UtilParser);

var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
var FlowErrors = makeErrorTemplates({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: "Cannot overwrite reserved type %0.",
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
  EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
  EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
  EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
  EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
  EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
  EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
  EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
  EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: "Unexpected reserved type %0.",
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
}, ErrorCodes.SyntaxError);

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(state) {
  return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
}

var exportSuggestions = {
  "const": "declare export var",
  "let": "declare export var",
  type: "export type",
  "interface": "export interface"
};

function partition(list, test) {
  var list1 = [];
  var list2 = [];

  for (var i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;

var flow = function flow(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass2) {
      _inherits(_class2, _superClass2);

      function _class2() {
        var _getPrototypeOf3;

        var _this10;

        _classCallCheck(this, _class2);

        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          args[_key10] = arguments[_key10];
        }

        _this10 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(_class2)).call.apply(_getPrototypeOf3, [this].concat(args)));
        _this10.flowPragma = undefined;
        return _this10;
      }

      _createClass(_class2, [{
        key: "getScopeHandler",
        value: function getScopeHandler() {
          return FlowScopeHandler;
        }
      }, {
        key: "shouldParseTypes",
        value: function shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
      }, {
        key: "shouldParseEnums",
        value: function shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
      }, {
        key: "finishToken",
        value: function finishToken(type, val) {
          if (type !== types$1.string && type !== types$1.semi && type !== types$1.interpreterDirective) {
            if (this.flowPragma === undefined) {
              this.flowPragma = null;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "finishToken", this).call(this, type, val);
        }
      }, {
        key: "addComment",
        value: function addComment(comment) {
          if (this.flowPragma === undefined) {
            var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches) ;else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "addComment", this).call(this, comment);
        }
      }, {
        key: "flowParseTypeInitialiser",
        value: function flowParseTypeInitialiser(tok) {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || types$1.colon);
          var type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
      }, {
        key: "flowParsePredicate",
        value: function flowParsePredicate() {
          var node = this.startNode();
          var moduloPos = this.state.start;
          this.next();
          this.expectContextual("checks");

          if (this.state.lastTokStart > moduloPos + 1) {
            this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
          }

          if (this.eat(types$1.parenL)) {
            node.value = this.parseExpression();
            this.expect(types$1.parenR);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
      }, {
        key: "flowParseTypeAndPredicateInitialiser",
        value: function flowParseTypeAndPredicateInitialiser() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(types$1.colon);
          var type = null;
          var predicate = null;

          if (this.match(types$1.modulo)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;

            if (this.match(types$1.modulo)) {
              predicate = this.flowParsePredicate();
            }
          }

          return [type, predicate];
        }
      }, {
        key: "flowParseDeclareClass",
        value: function flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
      }, {
        key: "flowParseDeclareFunction",
        value: function flowParseDeclareFunction(node) {
          this.next();
          var id = node.id = this.parseIdentifier();
          var typeNode = this.startNode();
          var typeContainer = this.startNode();

          if (this.isRelational("<")) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }

          this.expect(types$1.parenL);
          var tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode["this"] = tmp._this;
          this.expect(types$1.parenR);

          var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

          var _this$flowParseTypeAn2 = _slicedToArray(_this$flowParseTypeAn, 2);

          typeNode.returnType = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
          return this.finishNode(node, "DeclareFunction");
        }
      }, {
        key: "flowParseDeclare",
        value: function flowParseDeclare(node, insideModule) {
          if (this.match(types$1._class)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(types$1._function)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(types$1._var)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual("module")) {
            if (this.match(types$1.dot)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
              }

              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual("type")) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual("opaque")) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual("interface")) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(types$1._export)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
      }, {
        key: "flowParseDeclareVariable",
        value: function flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
      }, {
        key: "flowParseDeclareModule",
        value: function flowParseDeclareModule(node) {
          var _this11 = this;

          this.scope.enter(SCOPE_OTHER);

          if (this.match(types$1.string)) {
            node.id = this.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }

          var bodyNode = node.body = this.startNode();
          var body = bodyNode.body = [];
          this.expect(types$1.braceL);

          while (!this.match(types$1.braceR)) {
            var _bodyNode = this.startNode();

            if (this.match(types$1._import)) {
              this.next();

              if (!this.isContextual("type") && !this.match(types$1._typeof)) {
                this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
              }

              this.parseImport(_bodyNode);
            } else {
              this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
              _bodyNode = this.flowParseDeclare(_bodyNode, true);
            }

            body.push(_bodyNode);
          }

          this.scope.exit();
          this.expect(types$1.braceR);
          this.finishNode(bodyNode, "BlockStatement");
          var kind = null;
          var hasModuleExport = false;
          body.forEach(function (bodyElement) {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                _this11.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
              }

              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                _this11.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
              }

              if (kind === "ES") {
                _this11.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
              }

              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
      }, {
        key: "flowParseDeclareExportDeclaration",
        value: function flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(types$1._export);

          if (this.eat(types$1._default)) {
            if (this.match(types$1._function) || this.match(types$1._class)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }

            node["default"] = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
              var label = this.state.value;
              var suggestion = exportSuggestions[label];
              throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
            }

            if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node["default"] = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node["default"] = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
          }

          throw this.unexpected();
        }
      }, {
        key: "flowParseDeclareModuleExports",
        value: function flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual("exports");
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
      }, {
        key: "flowParseDeclareTypeAlias",
        value: function flowParseDeclareTypeAlias(node) {
          this.next();
          this.flowParseTypeAlias(node);
          node.type = "DeclareTypeAlias";
          return node;
        }
      }, {
        key: "flowParseDeclareOpaqueType",
        value: function flowParseDeclareOpaqueType(node) {
          this.next();
          this.flowParseOpaqueType(node, true);
          node.type = "DeclareOpaqueType";
          return node;
        }
      }, {
        key: "flowParseDeclareInterface",
        value: function flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
      }, {
        key: "flowParseInterfaceish",
        value: function flowParseInterfaceish(node) {
          var isClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node["extends"] = [];
          node["implements"] = [];
          node.mixins = [];

          if (this.eat(types$1._extends)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(types$1.comma));
          }

          if (this.isContextual("mixins")) {
            this.next();

            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(types$1.comma));
          }

          if (this.isContextual("implements")) {
            this.next();

            do {
              node["implements"].push(this.flowParseInterfaceExtends());
            } while (this.eat(types$1.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
      }, {
        key: "flowParseInterfaceExtends",
        value: function flowParseInterfaceExtends() {
          var node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          return this.finishNode(node, "InterfaceExtends");
        }
      }, {
        key: "flowParseInterface",
        value: function flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
      }, {
        key: "checkNotUnderscore",
        value: function checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
          }
        }
      }, {
        key: "checkReservedType",
        value: function checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word)) return;
          this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
        }
      }, {
        key: "flowParseRestrictedIdentifier",
        value: function flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.start, declaration);
          return this.parseIdentifier(liberal);
        }
      }, {
        key: "flowParseTypeAlias",
        value: function flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.right = this.flowParseTypeInitialiser(types$1.eq);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
      }, {
        key: "flowParseOpaqueType",
        value: function flowParseOpaqueType(node, declare) {
          this.expectContextual("type");
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }

          node.supertype = null;

          if (this.match(types$1.colon)) {
            node.supertype = this.flowParseTypeInitialiser(types$1.colon);
          }

          node.impltype = null;

          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(types$1.eq);
          }

          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
      }, {
        key: "flowParseTypeParameter",
        value: function flowParseTypeParameter() {
          var requireDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var nodeStart = this.state.start;
          var node = this.startNode();
          var variance = this.flowParseVariance();
          var ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;

          if (this.match(types$1.eq)) {
            this.eat(types$1.eq);
            node["default"] = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
            }
          }

          return this.finishNode(node, "TypeParameter");
        }
      }, {
        key: "flowParseTypeParameterDeclaration",
        value: function flowParseTypeParameterDeclaration() {
          var oldInType = this.state.inType;
          var node = this.startNode();
          node.params = [];
          this.state.inType = true;

          if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          var defaultRequired = false;

          do {
            var typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);

            if (typeParameter["default"]) {
              defaultRequired = true;
            }

            if (!this.isRelational(">")) {
              this.expect(types$1.comma);
            }
          } while (!this.isRelational(">"));

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
      }, {
        key: "flowParseTypeParameterInstantiation",
        value: function flowParseTypeParameterInstantiation() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseType());

            if (!this.isRelational(">")) {
              this.expect(types$1.comma);
            }
          }

          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseTypeParameterInstantiationCallOrNew",
        value: function flowParseTypeParameterInstantiationCallOrNew() {
          var node = this.startNode();
          var oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expectRelational("<");

          while (!this.isRelational(">")) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());

            if (!this.isRelational(">")) {
              this.expect(types$1.comma);
            }
          }

          this.expectRelational(">");
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
      }, {
        key: "flowParseInterfaceType",
        value: function flowParseInterfaceType() {
          var node = this.startNode();
          this.expectContextual("interface");
          node["extends"] = [];

          if (this.eat(types$1._extends)) {
            do {
              node["extends"].push(this.flowParseInterfaceExtends());
            } while (this.eat(types$1.comma));
          }

          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
      }, {
        key: "flowParseObjectPropertyKey",
        value: function flowParseObjectPropertyKey() {
          return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
        }
      }, {
        key: "flowParseObjectTypeIndexer",
        value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
          node["static"] = isStatic;

          if (this.lookahead().type === types$1.colon) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }

          this.expect(types$1.bracketR);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
      }, {
        key: "flowParseObjectTypeInternalSlot",
        value: function flowParseObjectTypeInternalSlot(node, isStatic) {
          node["static"] = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(types$1.bracketR);
          this.expect(types$1.bracketR);

          if (this.isRelational("<") || this.match(types$1.parenL)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;

            if (this.eat(types$1.question)) {
              node.optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
          }

          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
      }, {
        key: "flowParseObjectTypeMethodish",
        value: function flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node["this"] = null;

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          this.expect(types$1.parenL);

          if (this.match(types$1._this)) {
            node["this"] = this.flowParseFunctionTypeParam(true);
            node["this"].name = null;

            if (!this.match(types$1.parenR)) {
              this.expect(types$1.comma);
            }
          }

          while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
            node.params.push(this.flowParseFunctionTypeParam(false));

            if (!this.match(types$1.parenR)) {
              this.expect(types$1.comma);
            }
          }

          if (this.eat(types$1.ellipsis)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }

          this.expect(types$1.parenR);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
      }, {
        key: "flowParseObjectTypeCallProperty",
        value: function flowParseObjectTypeCallProperty(node, isStatic) {
          var valueNode = this.startNode();
          node["static"] = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
      }, {
        key: "flowParseObjectType",
        value: function flowParseObjectType(_ref4) {
          var allowStatic = _ref4.allowStatic,
              allowExact = _ref4.allowExact,
              allowSpread = _ref4.allowSpread,
              allowProto = _ref4.allowProto,
              allowInexact = _ref4.allowInexact;
          var oldInType = this.state.inType;
          this.state.inType = true;
          var nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          var endDelim;
          var exact;
          var inexact = false;

          if (allowExact && this.match(types$1.braceBarL)) {
            this.expect(types$1.braceBarL);
            endDelim = types$1.braceBarR;
            exact = true;
          } else {
            this.expect(types$1.braceL);
            endDelim = types$1.braceR;
            exact = false;
          }

          nodeStart.exact = exact;

          while (!this.match(endDelim)) {
            var isStatic = false;
            var protoStart = null;
            var inexactStart = null;
            var node = this.startNode();

            if (allowProto && this.isContextual("proto")) {
              var lookahead = this.lookahead();

              if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
                this.next();
                protoStart = this.state.start;
                allowStatic = false;
              }
            }

            if (allowStatic && this.isContextual("static")) {
              var _lookahead = this.lookahead();

              if (_lookahead.type !== types$1.colon && _lookahead.type !== types$1.question) {
                this.next();
                isStatic = true;
              }
            }

            var variance = this.flowParseVariance();

            if (this.eat(types$1.bracketL)) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (this.eat(types$1.bracketL)) {
                if (variance) {
                  this.unexpected(variance.start);
                }

                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(types$1.parenL) || this.isRelational("<")) {
              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              var kind = "init";

              if (this.isContextual("get") || this.isContextual("set")) {
                var _lookahead2 = this.lookahead();

                if (_lookahead2.type === types$1.name || _lookahead2.type === types$1.string || _lookahead2.type === types$1.num) {
                  kind = this.state.value;
                  this.next();
                }
              }

              var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

              if (propOrInexact === null) {
                inexact = true;
                inexactStart = this.state.lastTokStart;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }

            this.flowObjectTypeSemicolon();

            if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
              this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
            }
          }

          this.expect(endDelim);

          if (allowSpread) {
            nodeStart.inexact = inexact;
          }

          var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
      }, {
        key: "flowParseObjectTypeProperty",
        value: function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
          if (this.eat(types$1.ellipsis)) {
            var isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);

            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
              } else if (!allowInexact) {
                this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
              }

              if (variance) {
                this.raise(variance.start, FlowErrors.InexactVariance);
              }

              return null;
            }

            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
            }

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.SpreadVariance);
            }

            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node["static"] = isStatic;
            node.proto = protoStart != null;
            node.kind = kind;
            var optional = false;

            if (this.isRelational("<") || this.match(types$1.parenL)) {
              node.method = true;

              if (protoStart != null) {
                this.unexpected(protoStart);
              }

              if (variance) {
                this.unexpected(variance.start);
              }

              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }

              if (!allowSpread && node.key.name === "constructor" && node.value["this"]) {
                this.raise(node.value["this"].start, FlowErrors.ThisParamBannedInConstructor);
              }
            } else {
              if (kind !== "init") this.unexpected();
              node.method = false;

              if (this.eat(types$1.question)) {
                optional = true;
              }

              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }

            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
      }, {
        key: "flowCheckGetterSetterParams",
        value: function flowCheckGetterSetterParams(property) {
          var paramCount = property.kind === "get" ? 0 : 1;
          var start = property.start;
          var length = property.value.params.length + (property.value.rest ? 1 : 0);

          if (property.value["this"]) {
            this.raise(property.value["this"].start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
          }

          if (length !== paramCount) {
            if (property.kind === "get") {
              this.raise(start, ErrorMessages.BadGetterArity);
            } else {
              this.raise(start, ErrorMessages.BadSetterArity);
            }
          }

          if (property.kind === "set" && property.value.rest) {
            this.raise(start, ErrorMessages.BadSetterRestParameter);
          }
        }
      }, {
        key: "flowObjectTypeSemicolon",
        value: function flowObjectTypeSemicolon() {
          if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
            this.unexpected();
          }
        }
      }, {
        key: "flowParseQualifiedTypeIdentifier",
        value: function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          var node = id || this.flowParseRestrictedIdentifier(true);

          while (this.eat(types$1.dot)) {
            var node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }

          return node;
        }
      }, {
        key: "flowParseGenericType",
        value: function flowParseGenericType(startPos, startLoc, id) {
          var node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }

          return this.finishNode(node, "GenericTypeAnnotation");
        }
      }, {
        key: "flowParseTypeofType",
        value: function flowParseTypeofType() {
          var node = this.startNode();
          this.expect(types$1._typeof);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
      }, {
        key: "flowParseTupleType",
        value: function flowParseTupleType() {
          var node = this.startNode();
          node.types = [];
          this.expect(types$1.bracketL);

          while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
            node.types.push(this.flowParseType());
            if (this.match(types$1.bracketR)) break;
            this.expect(types$1.comma);
          }

          this.expect(types$1.bracketR);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
      }, {
        key: "flowParseFunctionTypeParam",
        value: function flowParseFunctionTypeParam(first) {
          var name = null;
          var optional = false;
          var typeAnnotation = null;
          var node = this.startNode();
          var lh = this.lookahead();
          var isThis = this.state.type === types$1._this;

          if (lh.type === types$1.colon || lh.type === types$1.question) {
            if (isThis && !first) {
              this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
            }

            name = this.parseIdentifier(isThis);

            if (this.eat(types$1.question)) {
              optional = true;

              if (isThis) {
                this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
              }
            }

            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }

          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "reinterpretTypeAsFunctionTypeParam",
        value: function reinterpretTypeAsFunctionTypeParam(type) {
          var node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
      }, {
        key: "flowParseFunctionTypeParams",
        value: function flowParseFunctionTypeParams() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var rest = null;
          var _this = null;

          if (this.match(types$1._this)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;

            if (!this.match(types$1.parenR)) {
              this.expect(types$1.comma);
            }
          }

          while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
            params.push(this.flowParseFunctionTypeParam(false));

            if (!this.match(types$1.parenR)) {
              this.expect(types$1.comma);
            }
          }

          if (this.eat(types$1.ellipsis)) {
            rest = this.flowParseFunctionTypeParam(false);
          }

          return {
            params: params,
            rest: rest,
            _this: _this
          };
        }
      }, {
        key: "flowIdentToTypeAnnotation",
        value: function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");

            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");

            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");

            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");

            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");

            case "string":
              return this.finishNode(node, "StringTypeAnnotation");

            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");

            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
      }, {
        key: "flowParsePrimaryType",
        value: function flowParsePrimaryType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.startNode();
          var tmp;
          var type;
          var isGroupedType = false;
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;

          switch (this.state.type) {
            case types$1.name:
              if (this.isContextual("interface")) {
                return this.flowParseInterfaceType();
              }

              return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

            case types$1.braceL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });

            case types$1.braceBarL:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });

            case types$1.bracketL:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;

            case types$1.relational:
              if (this.state.value === "<") {
                node.typeParameters = this.flowParseTypeParameterDeclaration();
                this.expect(types$1.parenL);
                tmp = this.flowParseFunctionTypeParams();
                node.params = tmp.params;
                node.rest = tmp.rest;
                node["this"] = tmp._this;
                this.expect(types$1.parenR);
                this.expect(types$1.arrow);
                node.returnType = this.flowParseType();
                return this.finishNode(node, "FunctionTypeAnnotation");
              }

              break;

            case types$1.parenL:
              this.next();

              if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
                if (this.match(types$1.name) || this.match(types$1._this)) {
                  var token = this.lookahead().type;
                  isGroupedType = token !== types$1.question && token !== types$1.colon;
                } else {
                  isGroupedType = true;
                }
              }

              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;

                if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
                  this.expect(types$1.parenR);
                  return type;
                } else {
                  this.eat(types$1.comma);
                }
              }

              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }

              node.params = tmp.params;
              node.rest = tmp.rest;
              node["this"] = tmp._this;
              this.expect(types$1.parenR);
              this.expect(types$1.arrow);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");

            case types$1.string:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

            case types$1._true:
            case types$1._false:
              node.value = this.match(types$1._true);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");

            case types$1.plusMin:
              if (this.state.value === "-") {
                this.next();

                if (this.match(types$1.num)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }

                if (this.match(types$1.bigint)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }

                throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
              }

              throw this.unexpected();

            case types$1.num:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

            case types$1.bigint:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

            case types$1._void:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");

            case types$1._null:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");

            case types$1._this:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");

            case types$1.star:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");

            default:
              if (this.state.type.keyword === "typeof") {
                return this.flowParseTypeofType();
              } else if (this.state.type.keyword) {
                var label = this.state.type.label;
                this.next();
                return _get(_getPrototypeOf(_class2.prototype), "createIdentifier", this).call(this, node, label);
              }

          }

          throw this.unexpected();
        }
      }, {
        key: "flowParsePostfixType",
        value: function flowParsePostfixType() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var type = this.flowParsePrimaryType();
          var seenOptionalIndexedAccess = false;

          while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
            var node = this.startNodeAt(startPos, startLoc);
            var optional = this.eat(types$1.questionDot);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(types$1.bracketL);

            if (!optional && this.match(types$1.bracketR)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(types$1.bracketR);

              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }

          return type;
        }
      }, {
        key: "flowParsePrefixType",
        value: function flowParsePrefixType() {
          var node = this.startNode();

          if (this.eat(types$1.question)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
      }, {
        key: "flowParseAnonFunctionWithoutParens",
        value: function flowParseAnonFunctionWithoutParens() {
          var param = this.flowParsePrefixType();

          if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
            var node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node["this"] = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          return param;
        }
      }, {
        key: "flowParseIntersectionType",
        value: function flowParseIntersectionType() {
          var node = this.startNode();
          this.eat(types$1.bitwiseAND);
          var type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];

          while (this.eat(types$1.bitwiseAND)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
      }, {
        key: "flowParseUnionType",
        value: function flowParseUnionType() {
          var node = this.startNode();
          this.eat(types$1.bitwiseOR);
          var type = this.flowParseIntersectionType();
          node.types = [type];

          while (this.eat(types$1.bitwiseOR)) {
            node.types.push(this.flowParseIntersectionType());
          }

          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
      }, {
        key: "flowParseType",
        value: function flowParseType() {
          var oldInType = this.state.inType;
          this.state.inType = true;
          var type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
      }, {
        key: "flowParseTypeOrImplicitInstantiation",
        value: function flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === types$1.name && this.state.value === "_") {
            var startPos = this.state.start;
            var startLoc = this.state.startLoc;
            var node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
      }, {
        key: "flowParseTypeAnnotation",
        value: function flowParseTypeAnnotation() {
          var node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
      }, {
        key: "flowParseTypeAnnotatableIdentifier",
        value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

          if (this.match(types$1.colon)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }

          return ident;
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "flowParseVariance",
        value: function flowParseVariance() {
          var variance = null;

          if (this.match(types$1.plusMin)) {
            variance = this.startNode();

            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }

            this.next();
            this.finishNode(variance, "Variance");
          }

          return variance;
        }
      }, {
        key: "parseFunctionBody",
        value: function parseFunctionBody(node, allowExpressionBody) {
          var _this12 = this;

          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseFunctionBody", _this12).call(_this12, node, true, isMethod);
            });
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseFunctionBody", this).call(this, node, false, isMethod);
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(types$1.colon)) {
            var typeNode = this.startNode();

            var _this$flowParseTypeAn3 = this.flowParseTypeAndPredicateInitialiser();

            var _this$flowParseTypeAn4 = _slicedToArray(_this$flowParseTypeAn3, 2);

            typeNode.typeAnnotation = _this$flowParseTypeAn4[0];
            node.predicate = _this$flowParseTypeAn4[1];
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }

          _get(_getPrototypeOf(_class2.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "parseStatement",
        value: function parseStatement(context, topLevel) {
          if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
            var lookahead = this.lookahead();

            if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
              var node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            var _node = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_node);
          }

          var stmt = _get(_getPrototypeOf(_class2.prototype), "parseStatement", this).call(this, context, topLevel);

          if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }

          return stmt;
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
                return this.flowParseDeclare(node);
              }
            } else if (this.match(types$1.name)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _get(_getPrototypeOf(_class2.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
            return false;
          }

          return _get(_getPrototypeOf(_class2.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual("enum")) {
            var node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          var _this13 = this;

          if (!this.match(types$1.question)) return expr;

          if (this.state.maybeInArrowParameters) {
            var nextCh = this.lookaheadCharCode();

            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }

          this.expect(types$1.question);
          var state = this.state.clone();
          var originalNoArrowAt = this.state.noArrowAt;
          var node = this.startNodeAt(startPos, startLoc);

          var _this$tryParseConditi = this.tryParseConditionalConsequent(),
              consequent = _this$tryParseConditi.consequent,
              failed = _this$tryParseConditi.failed;

          var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
              _this$getArrowLikeExp2 = _slicedToArray(_this$getArrowLikeExp, 2),
              valid = _this$getArrowLikeExp2[0],
              invalid = _this$getArrowLikeExp2[1];

          if (failed || invalid.length > 0) {
            var noArrowAt = _toConsumableArray(originalNoArrowAt);

            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;

              for (var i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }

              var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi2.consequent;
              failed = _this$tryParseConditi2.failed;

              var _this$getArrowLikeExp3 = this.getArrowLikeExpressions(consequent);

              var _this$getArrowLikeExp4 = _slicedToArray(_this$getArrowLikeExp3, 2);

              valid = _this$getArrowLikeExp4[0];
              invalid = _this$getArrowLikeExp4[1];
            }

            if (failed && valid.length > 1) {
              this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
            }

            if (failed && valid.length === 1) {
              this.state = state;
              this.state.noArrowAt = noArrowAt.concat(valid[0].start);

              var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

              consequent = _this$tryParseConditi3.consequent;
              failed = _this$tryParseConditi3.failed;
            }
          }

          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(types$1.colon);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
            return _this13.parseMaybeAssign(undefined, undefined);
          });
          return this.finishNode(node, "ConditionalExpression");
        }
      }, {
        key: "tryParseConditionalConsequent",
        value: function tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          var consequent = this.parseMaybeAssignAllowIn();
          var failed = !this.match(types$1.colon);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent: consequent,
            failed: failed
          };
        }
      }, {
        key: "getArrowLikeExpressions",
        value: function getArrowLikeExpressions(node, disallowInvalid) {
          var _this14 = this;

          var stack = [node];
          var arrows = [];

          while (stack.length !== 0) {
            var _node2 = stack.pop();

            if (_node2.type === "ArrowFunctionExpression") {
              if (_node2.typeParameters || !_node2.returnType) {
                this.finishArrowValidation(_node2);
              } else {
                arrows.push(_node2);
              }

              stack.push(_node2.body);
            } else if (_node2.type === "ConditionalExpression") {
              stack.push(_node2.consequent);
              stack.push(_node2.alternate);
            }
          }

          if (disallowInvalid) {
            arrows.forEach(function (node) {
              return _this14.finishArrowValidation(node);
            });
            return [arrows, []];
          }

          return partition(arrows, function (node) {
            return node.params.every(function (param) {
              return _this14.isAssignable(param, true);
            });
          });
        }
      }, {
        key: "finishArrowValidation",
        value: function finishArrowValidation(node) {
          var _node$extra;

          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

          _get(_getPrototypeOf(_class2.prototype), "checkParams", this).call(this, node, false, true);

          this.scope.exit();
        }
      }, {
        key: "forwardNoArrowParamsConversionAt",
        value: function forwardNoArrowParamsConversionAt(node, parse) {
          var result;

          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse();
          }

          return result;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(_class2.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(types$1.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types$1.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }

          return node;
        }
      }, {
        key: "assertModuleNodeAllowed",
        value: function assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "assertModuleNodeAllowed", this).call(this, node);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var decl = _get(_getPrototypeOf(_class2.prototype), "parseExport", this).call(this, node);

          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }

          return decl;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          if (this.isContextual("type")) {
            node.exportKind = "type";
            var declarationNode = this.startNode();
            this.next();

            if (this.match(types$1.braceL)) {
              node.specifiers = this.parseExportSpecifiers();
              this.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual("opaque")) {
            node.exportKind = "type";

            var _declarationNode = this.startNode();

            this.next();
            return this.flowParseOpaqueType(_declarationNode, false);
          } else if (this.isContextual("interface")) {
            node.exportKind = "type";

            var _declarationNode2 = this.startNode();

            this.next();
            return this.flowParseInterface(_declarationNode2);
          } else if (this.shouldParseEnums() && this.isContextual("enum")) {
            node.exportKind = "value";

            var _declarationNode3 = this.startNode();

            this.next();
            return this.flowParseEnumDeclaration(_declarationNode3);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "parseExportDeclaration", this).call(this, node);
          }
        }
      }, {
        key: "eatExportStar",
        value: function eatExportStar(node) {
          if (_get(_getPrototypeOf(_class2.prototype), "eatExportStar", this).apply(this, arguments)) return true;

          if (this.isContextual("type") && this.lookahead().type === types$1.star) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }

          return false;
        }
      }, {
        key: "maybeParseExportNamespaceSpecifier",
        value: function maybeParseExportNamespaceSpecifier(node) {
          var pos = this.state.start;

          var hasNamespace = _get(_getPrototypeOf(_class2.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node);

          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(pos);
          }

          return hasNamespace;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId) {
          _get(_getPrototypeOf(_class2.prototype), "parseClassId", this).call(this, node, isStatement, optionalId);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
      }, {
        key: "parseClassMember",
        value: function parseClassMember(classBody, member, state) {
          var pos = this.state.start;

          if (this.isContextual("declare")) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }

            member.declare = true;
          }

          _get(_getPrototypeOf(_class2.prototype), "parseClassMember", this).call(this, classBody, member, state);

          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(pos, FlowErrors.DeclareClassElement);
            } else if (member.value) {
              this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
            }
          }
        }
      }, {
        key: "isIterator",
        value: function isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
      }, {
        key: "readIterator",
        value: function readIterator() {
          var word = _get(_getPrototypeOf(_class2.prototype), "readWord1", this).call(this);

          var fullWord = "@@" + word;

          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
          }

          this.finishToken(types$1.name, fullWord);
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 123 && next === 124) {
            return this.finishOp(types$1.braceBarL, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types$1.relational, 1);
          } else if (this.state.inType && code === 63) {
            if (next === 46) {
              return this.finishOp(types$1.questionDot, 2);
            }

            return this.finishOp(types$1.question, 1);
          } else if (isIteratorStart(code, next)) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "getTokenFromCode", this).call(this, code);
          }
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "isAssignable", this).call(this, node, isBinding);
          }
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (node.type === "TypeCastExpression") {
            return _get(_getPrototypeOf(_class2.prototype), "toAssignable", this).call(this, this.typeCastToParameter(node), isLHS);
          } else {
            return _get(_getPrototypeOf(_class2.prototype), "toAssignable", this).call(this, node, isLHS);
          }
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList, trailingCommaPos, isLHS) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];

            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "toAssignableList", this).call(this, exprList, trailingCommaPos, isLHS);
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isParenthesizedExpr) {
          for (var i = 0; i < exprList.length; i++) {
            var _expr$extra;

            var expr = exprList[i];

            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
            }
          }

          return exprList;
        }
      }, {
        key: "parseArrayLike",
        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          var node = _get(_getPrototypeOf(_class2.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);

          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }

          return node;
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          if (expr.type !== "TypeCastExpression") {
            var _get7;

            for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
              args[_key11 - 1] = arguments[_key11];
            }

            return (_get7 = _get(_getPrototypeOf(_class2.prototype), "checkLVal", this)).call.apply(_get7, [this, expr].concat(args));
          }
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          if (this.match(types$1.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (this.match(types$1.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.isRelational("<") || _get(_getPrototypeOf(_class2.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(types$1.colon) || _get(_getPrototypeOf(_class2.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "isNonstaticConstructor",
        value: function isNonstaticConstructor(method) {
          return !this.match(types$1.colon) && _get(_getPrototypeOf(_class2.prototype), "isNonstaticConstructor", this).call(this, method);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

          if (method.params && isConstructor) {
            var params = method.params;

            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            var _params2 = method.value.params;

            if (_params2.length > 0 && this.isThisParam(_params2[0])) {
              this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
            }
          }
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.start);
          }

          delete method.variance;

          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(_class2.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }

          if (this.isContextual("implements")) {
            this.next();
            var implemented = node["implements"] = [];

            do {
              var _node3 = this.startNode();

              _node3.id = this.flowParseRestrictedIdentifier(true);

              if (this.isRelational("<")) {
                _node3.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                _node3.typeParameters = null;
              }

              implemented.push(this.finishNode(_node3, "ClassImplements"));
            } while (this.eat(types$1.comma));
          }
        }
      }, {
        key: "checkGetterSetterParams",
        value: function checkGetterSetterParams(method) {
          _get(_getPrototypeOf(_class2.prototype), "checkGetterSetterParams", this).call(this, method);

          var params = this.getObjectOrClassMethodParams(method);

          if (params.length > 0) {
            var param = params[0];

            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
            } else if (this.isThisParam(param)) {
              this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
            }
          }
        }
      }, {
        key: "parsePropertyName",
        value: function parsePropertyName(node, isPrivateNameAllowed) {
          var variance = this.flowParseVariance();

          var key = _get(_getPrototypeOf(_class2.prototype), "parsePropertyName", this).call(this, node, isPrivateNameAllowed);

          node.variance = variance;
          return key;
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.start);
          }

          delete prop.variance;
          var typeParameters;

          if (this.isRelational("<") && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(types$1.parenL)) this.unexpected();
          }

          _get(_getPrototypeOf(_class2.prototype), "parseObjPropValue", this).call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

          if (typeParameters) {
            (prop.value || prop).typeParameters = typeParameters;
          }
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(types$1.question)) {
            if (param.type !== "Identifier") {
              this.raise(param.start, FlowErrors.OptionalBindingPattern);
            }

            if (this.isThisParam(param)) {
              this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
            }

            param.optional = true;
          }

          if (this.match(types$1.colon)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
          }

          if (this.match(types$1.eq) && this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.ThisParamNoDefault);
          }

          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault(startPos, startLoc, left) {
          var node = _get(_getPrototypeOf(_class2.prototype), "parseMaybeDefault", this).call(this, startPos, startLoc, left);

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
          }

          return node;
        }
      }, {
        key: "shouldParseDefaultImport",
        value: function shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return _get(_getPrototypeOf(_class2.prototype), "shouldParseDefaultImport", this).call(this, node);
          }

          return isMaybeDefaultImport(this.state);
        }
      }, {
        key: "parseImportSpecifierLocal",
        value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
          node.specifiers.push(this.finishNode(specifier, type));
        }
      }, {
        key: "maybeParseDefaultImportSpecifier",
        value: function maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          var kind = null;

          if (this.match(types$1._typeof)) {
            kind = "typeof";
          } else if (this.isContextual("type")) {
            kind = "type";
          }

          if (kind) {
            var lh = this.lookahead();

            if (kind === "type" && lh.type === types$1.star) {
              this.unexpected(lh.start);
            }

            if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
              this.next();
              node.importKind = kind;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "maybeParseDefaultImportSpecifier", this).call(this, node);
        }
      }, {
        key: "parseImportSpecifier",
        value: function parseImportSpecifier(node) {
          var specifier = this.startNode();
          var firstIdentIsString = this.match(types$1.string);
          var firstIdent = this.parseModuleExportName();
          var specifierTypeKind = null;

          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }

          var isBinding = false;

          if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
            var as_ident = this.parseIdentifier(true);

            if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (firstIdentIsString) {
                throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
              }

              specifier.imported = firstIdent;
              specifier.importKind = null;
            }

            if (this.eatContextual("as")) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }

          var nodeIsTypeImport = hasTypeImportKind(node);
          var specifierIsTypeImport = hasTypeImportKind(specifier);

          if (nodeIsTypeImport && specifierIsTypeImport) {
            this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
          }

          if (nodeIsTypeImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.start, true);
          }

          if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.start, true, true);
          }

          this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
          node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          switch (this.state.type) {
            case types$1._this:
              return this.parseIdentifier(true);

            default:
              return _get(_getPrototypeOf(_class2.prototype), "parseBindingAtom", this).call(this);
          }
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var kind = node.kind;

          if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }

          _get(_getPrototypeOf(_class2.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(_class2.prototype), "parseVarId", this).call(this, decl, kind);

          if (this.match(types$1.colon)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types$1.colon)) {
            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(types$1.colon) || _get(_getPrototypeOf(_class2.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _this15 = this;

          var _jsx;

          var state = null;
          var jsx;

          if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", _this15).call(_this15, refExpressionErrors, afterLeftParse);
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;
            var curContext = context[context.length - 1];

            if (curContext === types.j_oTag) {
              context.length -= 2;
            } else if (curContext === types.j_expr) {
              context.length -= 1;
            }
          }

          if ((_jsx = jsx) != null && _jsx.error || this.isRelational("<")) {
            var _jsx2, _jsx3;

            state = state || this.state.clone();
            var typeParameters;
            var arrow = this.tryParse(function (abort) {
              var _arrowExpression$extr;

              typeParameters = _this15.flowParseTypeParameterDeclaration();

              var arrowExpression = _this15.forwardNoArrowParamsConversionAt(typeParameters, function () {
                var result = _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", _this15).call(_this15, refExpressionErrors, afterLeftParse);

                _this15.resetStartLocationFromNode(result, typeParameters);

                return result;
              });

              if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();

              var expr = _this15.maybeUnwrapTypeCastExpression(arrowExpression);

              if (expr.type !== "ArrowFunctionExpression") abort();
              expr.typeParameters = typeParameters;

              _this15.resetStartLocationFromNode(expr, typeParameters);

              return arrowExpression;
            }, state);
            var arrowExpression = null;

            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
                }

                return arrow.node;
              }

              arrowExpression = arrow.node;
            }

            if ((_jsx2 = jsx) != null && _jsx2.node) {
              this.state = jsx.failState;
              return jsx.node;
            }

            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }

            if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this16 = this;

          if (this.match(types$1.colon)) {
            var result = this.tryParse(function () {
              var oldNoAnonFunctionType = _this16.state.noAnonFunctionType;
              _this16.state.noAnonFunctionType = true;

              var typeNode = _this16.startNode();

              var _this16$flowParseType = _this16.flowParseTypeAndPredicateInitialiser();

              var _this16$flowParseType2 = _slicedToArray(_this16$flowParseType, 2);

              typeNode.typeAnnotation = _this16$flowParseType2[0];
              node.predicate = _this16$flowParseType2[1];
              _this16.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (_this16.canInsertSemicolon()) _this16.unexpected();
              if (!_this16.match(types$1.arrow)) _this16.unexpected();
              return typeNode;
            });
            if (result.thrown) return null;
            if (result.error) this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow(params) {
          return this.match(types$1.colon) || _get(_getPrototypeOf(_class2.prototype), "shouldParseArrow", this).call(this, params);
        }
      }, {
        key: "setArrowFunctionParameters",
        value: function setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            _get(_getPrototypeOf(_class2.prototype), "setArrowFunctionParameters", this).call(this, node, params);
          }
        }
      }, {
        key: "checkParams",
        value: function checkParams(node, allowDuplicates, isArrowFunction) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }

          for (var i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "checkParams", this).apply(this, arguments);
        }
      }, {
        key: "parseParenAndDistinguishExpression",
        value: function parseParenAndDistinguishExpression(canBeArrow) {
          return _get(_getPrototypeOf(_class2.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
      }, {
        key: "parseSubscripts",
        value: function parseSubscripts(base, startPos, startLoc, noCalls) {
          var _this17 = this;

          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
            var state = this.state.clone();
            var arrow = this.tryParse(function (abort) {
              return _this17.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
            }, state);
            if (!arrow.error && !arrow.aborted) return arrow.node;
            var result = this.tryParse(function () {
              return _get(_getPrototypeOf(_class2.prototype), "parseSubscripts", _this17).call(_this17, base, startPos, startLoc, noCalls);
            }, state);
            if (result.node && !result.error) return result.node;

            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }

            if (result.node) {
              this.state = result.failState;
              return result.node;
            }

            throw arrow.error || result.error;
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseSubscripts", this).call(this, base, startPos, startLoc, noCalls);
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          var _this18 = this;

          if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;

            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }

            this.next();
            var node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(types$1.parenL);
            node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
            var _node4 = this.startNodeAt(startPos, startLoc);

            _node4.callee = base;
            var result = this.tryParse(function () {
              _node4.typeArguments = _this18.flowParseTypeParameterInstantiationCallOrNew();

              _this18.expect(types$1.parenL);

              _node4.arguments = _this18.parseCallExpressionArguments(types$1.parenR, false);
              if (subscriptState.optionalChainMember) _node4.optional = false;
              return _this18.finishCallExpression(_node4, subscriptState.optionalChainMember);
            });

            if (result.node) {
              if (result.error) this.state = result.failState;
              return result.node;
            }
          }

          return _get(_getPrototypeOf(_class2.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, subscriptState);
        }
      }, {
        key: "parseNewArguments",
        value: function parseNewArguments(node) {
          var _this19 = this;

          var targs = null;

          if (this.shouldParseTypes() && this.isRelational("<")) {
            targs = this.tryParse(function () {
              return _this19.flowParseTypeParameterInstantiationCallOrNew();
            }).node;
          }

          node.typeArguments = targs;

          _get(_getPrototypeOf(_class2.prototype), "parseNewArguments", this).call(this, node);
        }
      }, {
        key: "parseAsyncArrowWithTypeParameters",
        value: function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node)) return;
          return this.parseArrowExpression(node, undefined, true);
        }
      }, {
        key: "readToken_mult_modulo",
        value: function readToken_mult_modulo(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "readToken_mult_modulo", this).call(this, code);
        }
      }, {
        key: "readToken_pipe_amp",
        value: function readToken_pipe_amp(code) {
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (code === 124 && next === 125) {
            this.finishOp(types$1.braceBarR, 2);
            return;
          }

          _get(_getPrototypeOf(_class2.prototype), "readToken_pipe_amp", this).call(this, code);
        }
      }, {
        key: "parseTopLevel",
        value: function parseTopLevel(file, program) {
          var fileNode = _get(_getPrototypeOf(_class2.prototype), "parseTopLevel", this).call(this, file, program);

          if (this.state.hasFlowComment) {
            this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
          }

          return fileNode;
        }
      }, {
        key: "skipBlockComment",
        value: function skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              this.unexpected(null, FlowErrors.NestedFlowComment);
            }

            this.hasFlowCommentCompletion();
            this.state.pos += this.skipFlowComment();
            this.state.hasFlowComment = true;
            return;
          }

          if (this.state.hasFlowComment) {
            var end = this.input.indexOf("*-/", this.state.pos += 2);

            if (end === -1) {
              throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
            }

            this.state.pos = end + 3;
            return;
          }

          return _get(_getPrototypeOf(_class2.prototype), "skipBlockComment", this).call(this);
        }
      }, {
        key: "skipFlowComment",
        value: function skipFlowComment() {
          var pos = this.state.pos;
          var shiftToFirstNonWhiteSpace = 2;

          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }

          var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }

          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }

          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }

          return false;
        }
      }, {
        key: "hasFlowCommentCompletion",
        value: function hasFlowCommentCompletion() {
          var end = this.input.indexOf("*/", this.state.pos);

          if (end === -1) {
            throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
          }
        }
      }, {
        key: "flowEnumErrorBooleanMemberNotInitialized",
        value: function flowEnumErrorBooleanMemberNotInitialized(pos, _ref5) {
          var enumName = _ref5.enumName,
              memberName = _ref5.memberName;
          this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
        }
      }, {
        key: "flowEnumErrorInvalidMemberName",
        value: function flowEnumErrorInvalidMemberName(pos, _ref6) {
          var enumName = _ref6.enumName,
              memberName = _ref6.memberName;
          var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
          this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
        }
      }, {
        key: "flowEnumErrorDuplicateMemberName",
        value: function flowEnumErrorDuplicateMemberName(pos, _ref7) {
          var enumName = _ref7.enumName,
              memberName = _ref7.memberName;
          this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
        }
      }, {
        key: "flowEnumErrorInconsistentMemberValues",
        value: function flowEnumErrorInconsistentMemberValues(pos, _ref8) {
          var enumName = _ref8.enumName;
          this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
        }
      }, {
        key: "flowEnumErrorInvalidExplicitType",
        value: function flowEnumErrorInvalidExplicitType(pos, _ref9) {
          var enumName = _ref9.enumName,
              suppliedType = _ref9.suppliedType;
          return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
        }
      }, {
        key: "flowEnumErrorInvalidMemberInitializer",
        value: function flowEnumErrorInvalidMemberInitializer(pos, _ref10) {
          var enumName = _ref10.enumName,
              explicitType = _ref10.explicitType,
              memberName = _ref10.memberName;
          var message = null;

          switch (explicitType) {
            case "boolean":
            case "number":
            case "string":
              message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
              break;

            case "symbol":
              message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
              break;

            default:
              message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
          }

          return this.raise(pos, message, enumName, memberName, explicitType);
        }
      }, {
        key: "flowEnumErrorNumberMemberNotInitialized",
        value: function flowEnumErrorNumberMemberNotInitialized(pos, _ref11) {
          var enumName = _ref11.enumName,
              memberName = _ref11.memberName;
          this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
        }
      }, {
        key: "flowEnumErrorStringMemberInconsistentlyInitailized",
        value: function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref12) {
          var enumName = _ref12.enumName;
          this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
        }
      }, {
        key: "flowEnumMemberInit",
        value: function flowEnumMemberInit() {
          var _this20 = this;

          var startPos = this.state.start;

          var endOfInit = function endOfInit() {
            return _this20.match(types$1.comma) || _this20.match(types$1.braceR);
          };

          switch (this.state.type) {
            case types$1.num:
              {
                var literal = this.parseNumericLiteral(this.state.value);

                if (endOfInit()) {
                  return {
                    type: "number",
                    pos: literal.start,
                    value: literal
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types$1.string:
              {
                var _literal = this.parseStringLiteral(this.state.value);

                if (endOfInit()) {
                  return {
                    type: "string",
                    pos: _literal.start,
                    value: _literal
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            case types$1._true:
            case types$1._false:
              {
                var _literal2 = this.parseBooleanLiteral(this.match(types$1._true));

                if (endOfInit()) {
                  return {
                    type: "boolean",
                    pos: _literal2.start,
                    value: _literal2
                  };
                }

                return {
                  type: "invalid",
                  pos: startPos
                };
              }

            default:
              return {
                type: "invalid",
                pos: startPos
              };
          }
        }
      }, {
        key: "flowEnumMemberRaw",
        value: function flowEnumMemberRaw() {
          var pos = this.state.start;
          var id = this.parseIdentifier(true);
          var init = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {
            type: "none",
            pos: pos
          };
          return {
            id: id,
            init: init
          };
        }
      }, {
        key: "flowEnumCheckExplicitTypeMismatch",
        value: function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
          var explicitType = context.explicitType;

          if (explicitType === null) {
            return;
          }

          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(pos, context);
          }
        }
      }, {
        key: "flowEnumMembers",
        value: function flowEnumMembers(_ref13) {
          var enumName = _ref13.enumName,
              explicitType = _ref13.explicitType;
          var seenNames = new Set();
          var members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          var hasUnknownMembers = false;

          while (!this.match(types$1.braceR)) {
            if (this.eat(types$1.ellipsis)) {
              hasUnknownMembers = true;
              break;
            }

            var memberNode = this.startNode();

            var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
                id = _this$flowEnumMemberR.id,
                init = _this$flowEnumMemberR.init;

            var memberName = id.name;

            if (memberName === "") {
              continue;
            }

            if (/^[a-z]/.test(memberName)) {
              this.flowEnumErrorInvalidMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            if (seenNames.has(memberName)) {
              this.flowEnumErrorDuplicateMemberName(id.start, {
                enumName: enumName,
                memberName: memberName
              });
            }

            seenNames.add(memberName);
            var context = {
              enumName: enumName,
              explicitType: explicitType,
              memberName: memberName
            };
            memberNode.id = id;

            switch (init.type) {
              case "boolean":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                  memberNode.init = init.value;
                  members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                }

              case "number":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                  memberNode.init = init.value;
                  members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                }

              case "string":
                {
                  this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                  memberNode.init = init.value;
                  members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                }

              case "invalid":
                {
                  throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
                }

              case "none":
                {
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                      break;

                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                      break;

                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
                }
            }

            if (!this.match(types$1.braceR)) {
              this.expect(types$1.comma);
            }
          }

          return {
            members: members,
            hasUnknownMembers: hasUnknownMembers
          };
        }
      }, {
        key: "flowEnumStringMembers",
        value: function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref14) {
          var enumName = _ref14.enumName;

          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = initializedMembers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var member = _step2.value;
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
                  enumName: enumName
                });
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            return defaultedMembers;
          } else {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = defaultedMembers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _member = _step3.value;
                this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
                  enumName: enumName
                });
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            return initializedMembers;
          }
        }
      }, {
        key: "flowEnumParseExplicitType",
        value: function flowEnumParseExplicitType(_ref15) {
          var enumName = _ref15.enumName;

          if (this.eatContextual("of")) {
            if (!this.match(types$1.name)) {
              throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: null
              });
            }

            var value = this.state.value;
            this.next();

            if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
              this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: enumName,
                suppliedType: value
              });
            }

            return value;
          }

          return null;
        }
      }, {
        key: "flowEnumBody",
        value: function flowEnumBody(node, _ref16) {
          var _this21 = this;

          var enumName = _ref16.enumName,
              nameLoc = _ref16.nameLoc;
          var explicitType = this.flowEnumParseExplicitType({
            enumName: enumName
          });
          this.expect(types$1.braceL);

          var _this$flowEnumMembers = this.flowEnumMembers({
            enumName: enumName,
            explicitType: explicitType
          }),
              members = _this$flowEnumMembers.members,
              hasUnknownMembers = _this$flowEnumMembers.hasUnknownMembers;

          node.hasUnknownMembers = hasUnknownMembers;

          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumBooleanBody");

            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumNumberBody");

            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName: enumName
              });
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumStringBody");

            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumSymbolBody");

            default:
              {
                var empty = function empty() {
                  node.members = [];

                  _this21.expect(types$1.braceR);

                  return _this21.finishNode(node, "EnumStringBody");
                };

                node.explicitType = false;
                var boolsLen = members.booleanMembers.length;
                var numsLen = members.numberMembers.length;
                var strsLen = members.stringMembers.length;
                var defaultedLen = members.defaultedMembers.length;

                if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                  return empty();
                } else if (!boolsLen && !numsLen) {
                  node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                    enumName: enumName
                  });
                  this.expect(types$1.braceR);
                  return this.finishNode(node, "EnumStringBody");
                } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = members.defaultedMembers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var member = _step4.value;
                      this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                        enumName: enumName,
                        memberName: member.id.name
                      });
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }

                  node.members = members.booleanMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node, "EnumBooleanBody");
                } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = undefined;

                  try {
                    for (var _iterator5 = members.defaultedMembers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      var _member2 = _step5.value;
                      this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                        enumName: enumName,
                        memberName: _member2.id.name
                      });
                    }
                  } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                        _iterator5["return"]();
                      }
                    } finally {
                      if (_didIteratorError5) {
                        throw _iteratorError5;
                      }
                    }
                  }

                  node.members = members.numberMembers;
                  this.expect(types$1.braceR);
                  return this.finishNode(node, "EnumNumberBody");
                } else {
                  this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                    enumName: enumName
                  });
                  return empty();
                }
              }
          }
        }
      }, {
        key: "flowParseEnumDeclaration",
        value: function flowParseEnumDeclaration(node) {
          var id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), {
            enumName: id.name,
            nameLoc: id.start
          });
          return this.finishNode(node, "EnumDeclaration");
        }
      }, {
        key: "isLookaheadToken_lt",
        value: function isLookaheadToken_lt() {
          var next = this.nextTokenStart();

          if (this.input.charCodeAt(next) === 60) {
            var afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }

          return false;
        }
      }, {
        key: "maybeUnwrapTypeCastExpression",
        value: function maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      }]);

      return _class2;
    }(superClass)
  );
};

var entities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};
var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;
var JsxErrors = makeErrorTemplates({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
}, ErrorCodes.SyntaxError);
types.j_oTag = new TokContext("<tag");
types.j_cTag = new TokContext("</tag");
types.j_expr = new TokContext("<tag>...</tag>", true);
types$1.jsxName = new TokenType("jsxName");
types$1.jsxText = new TokenType("jsxText", {
  beforeExpr: true
});
types$1.jsxTagStart = new TokenType("jsxTagStart", {
  startsExpr: true
});
types$1.jsxTagEnd = new TokenType("jsxTagEnd");

types$1.jsxTagStart.updateContext = function (context) {
  context.push(types.j_expr, types.j_oTag);
};

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = function jsx(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass3) {
      _inherits(_class3, _superClass3);

      function _class3() {
        _classCallCheck(this, _class3);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class3).apply(this, arguments));
      }

      _createClass(_class3, [{
        key: "jsxReadToken",
        value: function jsxReadToken() {
          var out = "";
          var chunkStart = this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
            }

            var ch = this.input.charCodeAt(this.state.pos);

            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.exprAllowed) {
                    ++this.state.pos;
                    return this.finishToken(types$1.jsxTagStart);
                  }

                  return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, ch);
                }

                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(types$1.jsxText, out);

              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;

              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }

            }
          }
        }
      }, {
        key: "jsxReadNewLine",
        value: function jsxReadNewLine(normalizeCRLF) {
          var ch = this.input.charCodeAt(this.state.pos);
          var out;
          ++this.state.pos;

          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
      }, {
        key: "jsxReadString",
        value: function jsxReadString(quote) {
          var out = "";
          var chunkStart = ++this.state.pos;

          for (;;) {
            if (this.state.pos >= this.length) {
              throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
            }

            var ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;

            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(types$1.string, out);
        }
      }, {
        key: "jsxReadEntity",
        value: function jsxReadEntity() {
          var str = "";
          var count = 0;
          var entity;
          var ch = this.input[this.state.pos];
          var startPos = ++this.state.pos;

          while (this.state.pos < this.length && count++ < 10) {
            ch = this.input[this.state.pos++];

            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);

                  if (HEX_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 16));
                  }
                } else {
                  str = str.substr(1);

                  if (DECIMAL_NUMBER.test(str)) {
                    entity = String.fromCodePoint(parseInt(str, 10));
                  }
                }
              } else {
                entity = entities[str];
              }

              break;
            }

            str += ch;
          }

          if (!entity) {
            this.state.pos = startPos;
            return "&";
          }

          return entity;
        }
      }, {
        key: "jsxReadWord",
        value: function jsxReadWord() {
          var ch;
          var start = this.state.pos;

          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);

          return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
        }
      }, {
        key: "jsxParseIdentifier",
        value: function jsxParseIdentifier() {
          var node = this.startNode();

          if (this.match(types$1.jsxName)) {
            node.name = this.state.value;
          } else if (this.state.type.keyword) {
            node.name = this.state.type.keyword;
          } else {
            this.unexpected();
          }

          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
      }, {
        key: "jsxParseNamespacedName",
        value: function jsxParseNamespacedName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var name = this.jsxParseIdentifier();
          if (!this.eat(types$1.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
      }, {
        key: "jsxParseElementName",
        value: function jsxParseElementName() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.jsxParseNamespacedName();

          if (node.type === "JSXNamespacedName") {
            return node;
          }

          while (this.eat(types$1.dot)) {
            var newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }

          return node;
        }
      }, {
        key: "jsxParseAttributeValue",
        value: function jsxParseAttributeValue() {
          var node;

          switch (this.state.type) {
            case types$1.braceL:
              node = this.startNode();
              this.next();
              node = this.jsxParseExpressionContainer(node);

              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(node.start, JsxErrors.AttributeIsEmpty);
              }

              return node;

            case types$1.jsxTagStart:
            case types$1.string:
              return this.parseExprAtom();

            default:
              throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
          }
        }
      }, {
        key: "jsxParseEmptyExpression",
        value: function jsxParseEmptyExpression() {
          var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
        }
      }, {
        key: "jsxParseSpreadChild",
        value: function jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.expect(types$1.braceR);
          return this.finishNode(node, "JSXSpreadChild");
        }
      }, {
        key: "jsxParseExpressionContainer",
        value: function jsxParseExpressionContainer(node) {
          if (this.match(types$1.braceR)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            var expression = this.parseExpression();
            node.expression = expression;
          }

          this.expect(types$1.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        }
      }, {
        key: "jsxParseAttribute",
        value: function jsxParseAttribute() {
          var node = this.startNode();

          if (this.eat(types$1.braceL)) {
            this.expect(types$1.ellipsis);
            node.argument = this.parseMaybeAssignAllowIn();
            this.expect(types$1.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }

          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
      }, {
        key: "jsxParseOpeningElementAt",
        value: function jsxParseOpeningElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types$1.jsxTagEnd)) {
            this.expect(types$1.jsxTagEnd);
            return this.finishNode(node, "JSXOpeningFragment");
          }

          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var attributes = [];

          while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
            attributes.push(this.jsxParseAttribute());
          }

          node.attributes = attributes;
          node.selfClosing = this.eat(types$1.slash);
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningElement");
        }
      }, {
        key: "jsxParseClosingElementAt",
        value: function jsxParseClosingElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);

          if (this.match(types$1.jsxTagEnd)) {
            this.expect(types$1.jsxTagEnd);
            return this.finishNode(node, "JSXClosingFragment");
          }

          node.name = this.jsxParseElementName();
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXClosingElement");
        }
      }, {
        key: "jsxParseElementAt",
        value: function jsxParseElementAt(startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          var children = [];
          var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          var closingElement = null;

          if (!openingElement.selfClosing) {
            contents: for (;;) {
              switch (this.state.type) {
                case types$1.jsxTagStart:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();

                  if (this.eat(types$1.slash)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }

                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;

                case types$1.jsxText:
                  children.push(this.parseExprAtom());
                  break;

                case types$1.braceL:
                  {
                    var _node5 = this.startNode();

                    this.next();

                    if (this.match(types$1.ellipsis)) {
                      children.push(this.jsxParseSpreadChild(_node5));
                    } else {
                      children.push(this.jsxParseExpressionContainer(_node5));
                    }

                    break;
                  }

                default:
                  throw this.unexpected();
              }
            }

            if (isFragment(openingElement) && !isFragment(closingElement)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
              }
            }
          }

          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }

          node.children = children;

          if (this.isRelational("<")) {
            throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
          }

          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
      }, {
        key: "jsxParseElement",
        value: function jsxParseElement() {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom(refExpressionErrors) {
          if (this.match(types$1.jsxText)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(types$1.jsxTagStart)) {
            return this.jsxParseElement();
          } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
            this.finishToken(types$1.jsxTagStart);
            return this.jsxParseElement();
          } else {
            return _get(_getPrototypeOf(_class3.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
          }
        }
      }, {
        key: "createLookaheadState",
        value: function createLookaheadState(state) {
          var lookaheadState = _get(_getPrototypeOf(_class3.prototype), "createLookaheadState", this).call(this, state);

          lookaheadState.inPropertyName = state.inPropertyName;
          return lookaheadState;
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (this.state.inPropertyName) return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, code);
          var context = this.curContext();

          if (context === types.j_expr) {
            return this.jsxReadToken();
          }

          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }

            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(types$1.jsxTagEnd);
            }

            if ((code === 34 || code === 39) && context === types.j_oTag) {
              return this.jsxReadString(code);
            }
          }

          if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(types$1.jsxTagStart);
          }

          return _get(_getPrototypeOf(_class3.prototype), "getTokenFromCode", this).call(this, code);
        }
      }, {
        key: "updateContext",
        value: function updateContext(prevType) {
          _get(_getPrototypeOf(_class3.prototype), "updateContext", this).call(this, prevType);

          var _this$state = this.state,
              context = _this$state.context,
              type = _this$state.type;

          if (type === types$1.slash && prevType === types$1.jsxTagStart) {
            context.splice(-2, 2, types.j_cTag);
            this.state.exprAllowed = false;
          } else if (type === types$1.jsxTagEnd) {
            var out = context.pop();

            if (out === types.j_oTag && prevType === types$1.slash || out === types.j_cTag) {
              context.pop();
              this.state.exprAllowed = context[context.length - 1] === types.j_expr;
            } else {
              this.state.exprAllowed = true;
            }
          } else if (type.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
            this.state.exprAllowed = false;
          } else {
            this.state.exprAllowed = type.beforeExpr;
          }
        }
      }]);

      return _class3;
    }(superClass)
  );
};

var TypeScriptScope =
/*#__PURE__*/
function (_Scope2) {
  _inherits(TypeScriptScope, _Scope2);

  function TypeScriptScope() {
    var _getPrototypeOf4;

    var _this22;

    _classCallCheck(this, TypeScriptScope);

    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    _this22 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(TypeScriptScope)).call.apply(_getPrototypeOf4, [this].concat(args)));
    _this22.types = new Set();
    _this22.enums = new Set();
    _this22.constEnums = new Set();
    _this22.classes = new Set();
    _this22.exportOnlyBindings = new Set();
    return _this22;
  }

  return TypeScriptScope;
}(Scope);

var TypeScriptScopeHandler =
/*#__PURE__*/
function (_ScopeHandler2) {
  _inherits(TypeScriptScopeHandler, _ScopeHandler2);

  function TypeScriptScopeHandler() {
    _classCallCheck(this, TypeScriptScopeHandler);

    return _possibleConstructorReturn(this, _getPrototypeOf(TypeScriptScopeHandler).apply(this, arguments));
  }

  _createClass(TypeScriptScopeHandler, [{
    key: "createScope",
    value: function createScope(flags) {
      return new TypeScriptScope(flags);
    }
  }, {
    key: "declareName",
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }

      _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "declareName", this).apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.add(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
    }
  }, {
    key: "isRedeclaredInScope",
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
        return true;
      }

      return _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "isRedeclaredInScope", this).apply(this, arguments);
    }
  }, {
    key: "checkLocalExport",
    value: function checkLocalExport(id) {
      var topLevelScope = this.scopeStack[0];
      var name = id.name;

      if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
        _get(_getPrototypeOf(TypeScriptScopeHandler.prototype), "checkLocalExport", this).call(this, id);
      }
    }
  }]);

  return TypeScriptScopeHandler;
}(ScopeHandler);

function nonNull(x) {
  if (x == null) {
    throw new Error("Unexpected ".concat(x, " value."));
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

var TSErrors = makeErrorTemplates({
  AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
  AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: "'declare' is not allowed in %0ters.",
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
  DuplicateModifier: "Duplicate modifier: '%0'.",
  EmptyHeritageClauseType: "'%0' list cannot be empty.",
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
  InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
}, ErrorCodes.SyntaxError);

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}

var typescript = function typescript(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass4) {
      _inherits(_class4, _superClass4);

      function _class4() {
        _classCallCheck(this, _class4);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class4).apply(this, arguments));
      }

      _createClass(_class4, [{
        key: "getScopeHandler",
        value: function getScopeHandler() {
          return TypeScriptScopeHandler;
        }
      }, {
        key: "tsIsIdentifier",
        value: function tsIsIdentifier() {
          return this.match(types$1.name);
        }
      }, {
        key: "tsTokenCanFollowModifier",
        value: function tsTokenCanFollowModifier() {
          return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
      }, {
        key: "tsNextTokenCanFollowModifier",
        value: function tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
      }, {
        key: "tsParseModifier",
        value: function tsParseModifier(allowedModifiers) {
          if (!this.match(types$1.name)) {
            return undefined;
          }

          var modifier = this.state.value;

          if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }

          return undefined;
        }
      }, {
        key: "tsParseModifiers",
        value: function tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
          var _this23 = this;

          var enforceOrder = function enforceOrder(pos, modifier, before, after) {
            if (modifier === before && modified[after]) {
              _this23.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
            }
          };

          var incompatible = function incompatible(pos, modifier, mod1, mod2) {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              _this23.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
            }
          };

          for (;;) {
            var startPos = this.state.start;
            var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
            if (!modifier) break;

            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
              } else {
                enforceOrder(startPos, modifier, modifier, "override");
                enforceOrder(startPos, modifier, modifier, "static");
                enforceOrder(startPos, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(startPos, TSErrors.DuplicateModifier, modifier);
              } else {
                enforceOrder(startPos, modifier, "static", "readonly");
                enforceOrder(startPos, modifier, "static", "override");
                enforceOrder(startPos, modifier, "override", "readonly");
                enforceOrder(startPos, modifier, "abstract", "override");
                incompatible(startPos, modifier, "declare", "override");
                incompatible(startPos, modifier, "static", "abstract");
              }

              modified[modifier] = true;
            }

            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(startPos, errorTemplate, modifier);
            }
          }
        }
      }, {
        key: "tsIsListTerminator",
        value: function tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(types$1.braceR);

            case "HeritageClauseElement":
              return this.match(types$1.braceL);

            case "TupleElementTypes":
              return this.match(types$1.bracketR);

            case "TypeParametersOrArguments":
              return this.isRelational(">");
          }

          throw new Error("Unreachable");
        }
      }, {
        key: "tsParseList",
        value: function tsParseList(kind, parseElement) {
          var result = [];

          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }

          return result;
        }
      }, {
        key: "tsParseDelimitedList",
        value: function tsParseDelimitedList(kind, parseElement) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
        }
      }, {
        key: "tsParseDelimitedListWorker",
        value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
          var result = [];

          for (;;) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }

            var element = parseElement();

            if (element == null) {
              return undefined;
            }

            result.push(element);

            if (this.eat(types$1.comma)) {
              continue;
            }

            if (this.tsIsListTerminator(kind)) {
              break;
            }

            if (expectSuccess) {
              this.expect(types$1.comma);
            }

            return undefined;
          }

          return result;
        }
      }, {
        key: "tsParseBracketedList",
        value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(types$1.bracketL);
            } else {
              this.expectRelational("<");
            }
          }

          var result = this.tsParseDelimitedList(kind, parseElement);

          if (bracket) {
            this.expect(types$1.bracketR);
          } else {
            this.expectRelational(">");
          }

          return result;
        }
      }, {
        key: "tsParseImportType",
        value: function tsParseImportType() {
          var node = this.startNode();
          this.expect(types$1._import);
          this.expect(types$1.parenL);

          if (!this.match(types$1.string)) {
            this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
          }

          node.argument = this.parseExprAtom();
          this.expect(types$1.parenR);

          if (this.eat(types$1.dot)) {
            node.qualifier = this.tsParseEntityName(true);
          }

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSImportType");
        }
      }, {
        key: "tsParseEntityName",
        value: function tsParseEntityName(allowReservedWords) {
          var entity = this.parseIdentifier();

          while (this.eat(types$1.dot)) {
            var node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }

          return entity;
        }
      }, {
        key: "tsParseTypeReference",
        value: function tsParseTypeReference() {
          var node = this.startNode();
          node.typeName = this.tsParseEntityName(false);

          if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSTypeReference");
        }
      }, {
        key: "tsParseThisTypePredicate",
        value: function tsParseThisTypePredicate(lhs) {
          this.next();
          var node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
      }, {
        key: "tsParseThisTypeNode",
        value: function tsParseThisTypeNode() {
          var node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
      }, {
        key: "tsParseTypeQuery",
        value: function tsParseTypeQuery() {
          var node = this.startNode();
          this.expect(types$1._typeof);

          if (this.match(types$1._import)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName(true);
          }

          return this.finishNode(node, "TSTypeQuery");
        }
      }, {
        key: "tsParseTypeParameter",
        value: function tsParseTypeParameter() {
          var node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(types$1._extends);
          node["default"] = this.tsEatThenParseType(types$1.eq);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsTryParseTypeParameters",
        value: function tsTryParseTypeParameters() {
          if (this.isRelational("<")) {
            return this.tsParseTypeParameters();
          }
        }
      }, {
        key: "tsParseTypeParameters",
        value: function tsParseTypeParameters() {
          var node = this.startNode();

          if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
            this.next();
          } else {
            this.unexpected();
          }

          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);

          if (node.params.length === 0) {
            this.raise(node.start, TSErrors.EmptyTypeParameters);
          }

          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
      }, {
        key: "tsTryNextParseConstantContext",
        value: function tsTryNextParseConstantContext() {
          if (this.lookahead().type === types$1._const) {
            this.next();
            return this.tsParseTypeReference();
          }

          return null;
        }
      }, {
        key: "tsFillSignature",
        value: function tsFillSignature(returnToken, signature) {
          var returnTokenRequired = returnToken === types$1.arrow;
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(types$1.parenL);
          signature.parameters = this.tsParseBindingListForSignature();

          if (returnTokenRequired) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
      }, {
        key: "tsParseBindingListForSignature",
        value: function tsParseBindingListForSignature() {
          var _this24 = this;

          return this.parseBindingList(types$1.parenR, 41).map(function (pattern) {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              _this24.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
            }

            return pattern;
          });
        }
      }, {
        key: "tsParseTypeMemberSemicolon",
        value: function tsParseTypeMemberSemicolon() {
          if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
            this.expect(types$1.semi);
          }
        }
      }, {
        key: "tsParseSignatureMember",
        value: function tsParseSignatureMember(kind, node) {
          this.tsFillSignature(types$1.colon, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
      }, {
        key: "tsIsUnambiguouslyIndexSignature",
        value: function tsIsUnambiguouslyIndexSignature() {
          this.next();
          return this.eat(types$1.name) && this.match(types$1.colon);
        }
      }, {
        key: "tsTryParseIndexSignature",
        value: function tsTryParseIndexSignature(node) {
          if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return undefined;
          }

          this.expect(types$1.bracketL);
          var id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(types$1.bracketR);
          node.parameters = [id];
          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
      }, {
        key: "tsParsePropertyOrMethodSignature",
        value: function tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(types$1.question)) node.optional = true;
          var nodeAny = node;

          if (this.match(types$1.parenL) || this.isRelational("<")) {
            if (readonly) {
              this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
            }

            var method = nodeAny;

            if (method.kind && this.isRelational("<")) {
              this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
            }

            this.tsFillSignature(types$1.colon, method);
            this.tsParseTypeMemberSemicolon();

            if (method.kind === "get") {
              if (method.parameters.length > 0) {
                this.raise(this.state.pos, ErrorMessages.BadGetterArity);

                if (this.isThisParam(method.parameters[0])) {
                  this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                }
              }
            } else if (method.kind === "set") {
              if (method.parameters.length !== 1) {
                this.raise(this.state.pos, ErrorMessages.BadSetterArity);
              } else {
                var firstParameter = method.parameters[0];

                if (this.isThisParam(firstParameter)) {
                  this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
                }

                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
                }

                if (firstParameter.type === "RestElement") {
                  this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
                }
              }

              if (method.typeAnnotation) {
                this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
              }
            } else {
              method.kind = "method";
            }

            return this.finishNode(method, "TSMethodSignature");
          } else {
            var property = nodeAny;
            if (readonly) property.readonly = true;
            var type = this.tsTryParseTypeAnnotation();
            if (type) property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
      }, {
        key: "tsParseTypeMember",
        value: function tsParseTypeMember() {
          var node = this.startNode();

          if (this.match(types$1.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }

          if (this.match(types$1._new)) {
            var id = this.startNode();
            this.next();

            if (this.match(types$1.parenL) || this.isRelational("<")) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }

          this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
          var idx = this.tsTryParseIndexSignature(node);

          if (idx) {
            return idx;
          }

          this.parsePropertyName(node, false);

          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            this.parsePropertyName(node, false);
          }

          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
      }, {
        key: "tsParseTypeLiteral",
        value: function tsParseTypeLiteral() {
          var node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
      }, {
        key: "tsParseObjectTypeMembers",
        value: function tsParseObjectTypeMembers() {
          this.expect(types$1.braceL);
          var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(types$1.braceR);
          return members;
        }
      }, {
        key: "tsIsStartOfMappedType",
        value: function tsIsStartOfMappedType() {
          this.next();

          if (this.eat(types$1.plusMin)) {
            return this.isContextual("readonly");
          }

          if (this.isContextual("readonly")) {
            this.next();
          }

          if (!this.match(types$1.bracketL)) {
            return false;
          }

          this.next();

          if (!this.tsIsIdentifier()) {
            return false;
          }

          this.next();
          return this.match(types$1._in);
        }
      }, {
        key: "tsParseMappedTypeParameter",
        value: function tsParseMappedTypeParameter() {
          var node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(types$1._in);
          return this.finishNode(node, "TSTypeParameter");
        }
      }, {
        key: "tsParseMappedType",
        value: function tsParseMappedType() {
          var node = this.startNode();
          this.expect(types$1.braceL);

          if (this.match(types$1.plusMin)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual("readonly");
          } else if (this.eatContextual("readonly")) {
            node.readonly = true;
          }

          this.expect(types$1.bracketL);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
          this.expect(types$1.bracketR);

          if (this.match(types$1.plusMin)) {
            node.optional = this.state.value;
            this.next();
            this.expect(types$1.question);
          } else if (this.eat(types$1.question)) {
            node.optional = true;
          }

          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(types$1.braceR);
          return this.finishNode(node, "TSMappedType");
        }
      }, {
        key: "tsParseTupleType",
        value: function tsParseTupleType() {
          var _this25 = this;

          var node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          var seenOptionalElement = false;
          var labeledElements = null;
          node.elementTypes.forEach(function (elementNode) {
            var _labeledElements;

            var _elementNode = elementNode,
                type = _elementNode.type;

            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              _this25.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
            }

            seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              type = elementNode.type;
            }

            var isLabeled = type === "TSNamedTupleMember";
            labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

            if (labeledElements !== isLabeled) {
              _this25.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
      }, {
        key: "tsParseTupleElementType",
        value: function tsParseTupleElementType() {
          var _this$state2 = this.state,
              startPos = _this$state2.start,
              startLoc = _this$state2.startLoc;
          var rest = this.eat(types$1.ellipsis);
          var type = this.tsParseType();
          var optional = this.eat(types$1.question);
          var labeled = this.eat(types$1.colon);

          if (labeled) {
            var labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;

            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
              labeledNode.label = type;
            }

            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            var optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }

          if (rest) {
            var restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }

          return type;
        }
      }, {
        key: "tsParseParenthesizedType",
        value: function tsParseParenthesizedType() {
          var node = this.startNode();
          this.expect(types$1.parenL);
          node.typeAnnotation = this.tsParseType();
          this.expect(types$1.parenR);
          return this.finishNode(node, "TSParenthesizedType");
        }
      }, {
        key: "tsParseFunctionOrConstructorType",
        value: function tsParseFunctionOrConstructorType(type, _abstract) {
          var node = this.startNode();

          if (type === "TSConstructorType") {
            node["abstract"] = !!_abstract;
            if (_abstract) this.next();
            this.next();
          }

          this.tsFillSignature(types$1.arrow, node);
          return this.finishNode(node, type);
        }
      }, {
        key: "tsParseLiteralTypeNode",
        value: function tsParseLiteralTypeNode() {
          var _this26 = this;

          var node = this.startNode();

          node.literal = function () {
            switch (_this26.state.type) {
              case types$1.num:
              case types$1.bigint:
              case types$1.string:
              case types$1._true:
              case types$1._false:
                return _this26.parseExprAtom();

              default:
                throw _this26.unexpected();
            }
          }();

          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "tsParseTemplateLiteralType",
        value: function tsParseTemplateLiteralType() {
          var node = this.startNode();
          node.literal = this.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
      }, {
        key: "parseTemplateSubstitution",
        value: function parseTemplateSubstitution() {
          if (this.state.inType) return this.tsParseType();
          return _get(_getPrototypeOf(_class4.prototype), "parseTemplateSubstitution", this).call(this);
        }
      }, {
        key: "tsParseThisTypeOrThisTypePredicate",
        value: function tsParseThisTypeOrThisTypePredicate() {
          var thisKeyword = this.tsParseThisTypeNode();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
      }, {
        key: "tsParseNonArrayType",
        value: function tsParseNonArrayType() {
          switch (this.state.type) {
            case types$1.name:
            case types$1._void:
            case types$1._null:
              {
                var type = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

                if (type !== undefined && this.lookaheadCharCode() !== 46) {
                  var node = this.startNode();
                  this.next();
                  return this.finishNode(node, type);
                }

                return this.tsParseTypeReference();
              }

            case types$1.string:
            case types$1.num:
            case types$1.bigint:
            case types$1._true:
            case types$1._false:
              return this.tsParseLiteralTypeNode();

            case types$1.plusMin:
              if (this.state.value === "-") {
                var _node6 = this.startNode();

                var nextToken = this.lookahead();

                if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
                  throw this.unexpected();
                }

                _node6.literal = this.parseMaybeUnary();
                return this.finishNode(_node6, "TSLiteralType");
              }

              break;

            case types$1._this:
              return this.tsParseThisTypeOrThisTypePredicate();

            case types$1._typeof:
              return this.tsParseTypeQuery();

            case types$1._import:
              return this.tsParseImportType();

            case types$1.braceL:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

            case types$1.bracketL:
              return this.tsParseTupleType();

            case types$1.parenL:
              return this.tsParseParenthesizedType();

            case types$1.backQuote:
              return this.tsParseTemplateLiteralType();
          }

          throw this.unexpected();
        }
      }, {
        key: "tsParseArrayTypeOrHigher",
        value: function tsParseArrayTypeOrHigher() {
          var type = this.tsParseNonArrayType();

          while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
            if (this.match(types$1.bracketR)) {
              var node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(types$1.bracketR);
              type = this.finishNode(node, "TSArrayType");
            } else {
              var _node7 = this.startNodeAtNode(type);

              _node7.objectType = type;
              _node7.indexType = this.tsParseType();
              this.expect(types$1.bracketR);
              type = this.finishNode(_node7, "TSIndexedAccessType");
            }
          }

          return type;
        }
      }, {
        key: "tsParseTypeOperator",
        value: function tsParseTypeOperator(operator) {
          var node = this.startNode();
          this.expectContextual(operator);
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }

          return this.finishNode(node, "TSTypeOperator");
        }
      }, {
        key: "tsCheckTypeAnnotationForReadOnly",
        value: function tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;

            default:
              this.raise(node.start, TSErrors.UnexpectedReadonly);
          }
        }
      }, {
        key: "tsParseInferType",
        value: function tsParseInferType() {
          var node = this.startNode();
          this.expectContextual("infer");
          var typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
      }, {
        key: "tsParseTypeOperatorOrHigher",
        value: function tsParseTypeOperatorOrHigher() {
          var _this27 = this;

          var operator = ["keyof", "unique", "readonly"].find(function (kw) {
            return _this27.isContextual(kw);
          });
          return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
        }
      }, {
        key: "tsParseUnionOrIntersectionType",
        value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          var node = this.startNode();
          var hasLeadingOperator = this.eat(operator);
          var types = [];

          do {
            types.push(parseConstituentType());
          } while (this.eat(operator));

          if (types.length === 1 && !hasLeadingOperator) {
            return types[0];
          }

          node.types = types;
          return this.finishNode(node, kind);
        }
      }, {
        key: "tsParseIntersectionTypeOrHigher",
        value: function tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
        }
      }, {
        key: "tsParseUnionTypeOrHigher",
        value: function tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
        }
      }, {
        key: "tsIsStartOfFunctionType",
        value: function tsIsStartOfFunctionType() {
          if (this.isRelational("<")) {
            return true;
          }

          return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
      }, {
        key: "tsSkipParameterStart",
        value: function tsSkipParameterStart() {
          if (this.match(types$1.name) || this.match(types$1._this)) {
            this.next();
            return true;
          }

          if (this.match(types$1.braceL)) {
            var braceStackCounter = 1;
            this.next();

            while (braceStackCounter > 0) {
              if (this.match(types$1.braceL)) {
                ++braceStackCounter;
              } else if (this.match(types$1.braceR)) {
                --braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          if (this.match(types$1.bracketL)) {
            var _braceStackCounter = 1;
            this.next();

            while (_braceStackCounter > 0) {
              if (this.match(types$1.bracketL)) {
                ++_braceStackCounter;
              } else if (this.match(types$1.bracketR)) {
                --_braceStackCounter;
              }

              this.next();
            }

            return true;
          }

          return false;
        }
      }, {
        key: "tsIsUnambiguouslyStartOfFunctionType",
        value: function tsIsUnambiguouslyStartOfFunctionType() {
          this.next();

          if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
            return true;
          }

          if (this.tsSkipParameterStart()) {
            if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
              return true;
            }

            if (this.match(types$1.parenR)) {
              this.next();

              if (this.match(types$1.arrow)) {
                return true;
              }
            }
          }

          return false;
        }
      }, {
        key: "tsParseTypeOrTypePredicateAnnotation",
        value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
          var _this28 = this;

          return this.tsInType(function () {
            var t = _this28.startNode();

            _this28.expect(returnToken);

            var node = _this28.startNode();

            var asserts = !!_this28.tsTryParse(_this28.tsParseTypePredicateAsserts.bind(_this28));

            if (asserts && _this28.match(types$1._this)) {
              var thisTypePredicate = _this28.tsParseThisTypeOrThisTypePredicate();

              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = _this28.finishNode(node, "TSTypePredicate");
              } else {
                _this28.resetStartLocationFromNode(thisTypePredicate, node);

                thisTypePredicate.asserts = true;
              }

              t.typeAnnotation = thisTypePredicate;
              return _this28.finishNode(t, "TSTypeAnnotation");
            }

            var typePredicateVariable = _this28.tsIsIdentifier() && _this28.tsTryParse(_this28.tsParseTypePredicatePrefix.bind(_this28));

            if (!typePredicateVariable) {
              if (!asserts) {
                return _this28.tsParseTypeAnnotation(false, t);
              }

              node.parameterName = _this28.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t.typeAnnotation = _this28.finishNode(node, "TSTypePredicate");
              return _this28.finishNode(t, "TSTypeAnnotation");
            }

            var type = _this28.tsParseTypeAnnotation(false);

            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = _this28.finishNode(node, "TSTypePredicate");
            return _this28.finishNode(t, "TSTypeAnnotation");
          });
        }
      }, {
        key: "tsTryParseTypeOrTypePredicateAnnotation",
        value: function tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : undefined;
        }
      }, {
        key: "tsTryParseTypeAnnotation",
        value: function tsTryParseTypeAnnotation() {
          return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : undefined;
        }
      }, {
        key: "tsTryParseType",
        value: function tsTryParseType() {
          return this.tsEatThenParseType(types$1.colon);
        }
      }, {
        key: "tsParseTypePredicatePrefix",
        value: function tsParseTypePredicatePrefix() {
          var id = this.parseIdentifier();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
      }, {
        key: "tsParseTypePredicateAsserts",
        value: function tsParseTypePredicateAsserts() {
          if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
            return false;
          }

          var containsEsc = this.state.containsEsc;
          this.next();

          if (!this.match(types$1.name) && !this.match(types$1._this)) {
            return false;
          }

          if (containsEsc) {
            this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
          }

          return true;
        }
      }, {
        key: "tsParseTypeAnnotation",
        value: function tsParseTypeAnnotation() {
          var _this29 = this;

          var eatColon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();
          this.tsInType(function () {
            if (eatColon) _this29.expect(types$1.colon);
            t.typeAnnotation = _this29.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        }
      }, {
        key: "tsParseType",
        value: function tsParseType() {
          assert(this.state.inType);
          var type = this.tsParseNonConditionalType();

          if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
            return type;
          }

          var node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsParseNonConditionalType();
          this.expect(types$1.question);
          node.trueType = this.tsParseType();
          this.expect(types$1.colon);
          node.falseType = this.tsParseType();
          return this.finishNode(node, "TSConditionalType");
        }
      }, {
        key: "isAbstractConstructorSignature",
        value: function isAbstractConstructorSignature() {
          return this.isContextual("abstract") && this.lookahead().type === types$1._new;
        }
      }, {
        key: "tsParseNonConditionalType",
        value: function tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }

          if (this.match(types$1._new)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }

          return this.tsParseUnionTypeOrHigher();
        }
      }, {
        key: "tsParseTypeAssertion",
        value: function tsParseTypeAssertion() {
          var node = this.startNode();

          var _const = this.tsTryNextParseConstantContext();

          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expectRelational(">");
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
      }, {
        key: "tsParseHeritageClause",
        value: function tsParseHeritageClause(descriptor) {
          var originalStart = this.state.start;
          var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

          if (!delimitedList.length) {
            this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
          }

          return delimitedList;
        }
      }, {
        key: "tsParseExpressionWithTypeArguments",
        value: function tsParseExpressionWithTypeArguments() {
          var node = this.startNode();
          node.expression = this.tsParseEntityName(false);

          if (this.isRelational("<")) {
            node.typeParameters = this.tsParseTypeArguments();
          }

          return this.finishNode(node, "TSExpressionWithTypeArguments");
        }
      }, {
        key: "tsParseInterfaceDeclaration",
        value: function tsParseInterfaceDeclaration(node) {
          if (this.match(types$1.name)) {
            node.id = this.parseIdentifier();
            this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(this.state.start, TSErrors.MissingInterfaceName);
          }

          node.typeParameters = this.tsTryParseTypeParameters();

          if (this.eat(types$1._extends)) {
            node["extends"] = this.tsParseHeritageClause("extends");
          }

          var body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
      }, {
        key: "tsParseTypeAliasDeclaration",
        value: function tsParseTypeAliasDeclaration(node) {
          var _this30 = this;

          node.id = this.parseIdentifier();
          this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
          node.typeParameters = this.tsTryParseTypeParameters();
          node.typeAnnotation = this.tsInType(function () {
            _this30.expect(types$1.eq);

            if (_this30.isContextual("intrinsic") && _this30.lookahead().type !== types$1.dot) {
              var _node8 = _this30.startNode();

              _this30.next();

              return _this30.finishNode(_node8, "TSIntrinsicKeyword");
            }

            return _this30.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
      }, {
        key: "tsInNoContext",
        value: function tsInNoContext(cb) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];

          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
      }, {
        key: "tsInType",
        value: function tsInType(cb) {
          var oldInType = this.state.inType;
          this.state.inType = true;

          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
      }, {
        key: "tsEatThenParseType",
        value: function tsEatThenParseType(token) {
          return !this.match(token) ? undefined : this.tsNextThenParseType();
        }
      }, {
        key: "tsExpectThenParseType",
        value: function tsExpectThenParseType(token) {
          var _this31 = this;

          return this.tsDoThenParseType(function () {
            return _this31.expect(token);
          });
        }
      }, {
        key: "tsNextThenParseType",
        value: function tsNextThenParseType() {
          var _this32 = this;

          return this.tsDoThenParseType(function () {
            return _this32.next();
          });
        }
      }, {
        key: "tsDoThenParseType",
        value: function tsDoThenParseType(cb) {
          var _this33 = this;

          return this.tsInType(function () {
            cb();
            return _this33.tsParseType();
          });
        }
      }, {
        key: "tsParseEnumMember",
        value: function tsParseEnumMember() {
          var node = this.startNode();
          node.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);

          if (this.eat(types$1.eq)) {
            node.initializer = this.parseMaybeAssignAllowIn();
          }

          return this.finishNode(node, "TSEnumMember");
        }
      }, {
        key: "tsParseEnumDeclaration",
        value: function tsParseEnumDeclaration(node, isConst) {
          if (isConst) node["const"] = true;
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(types$1.braceL);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(types$1.braceR);
          return this.finishNode(node, "TSEnumDeclaration");
        }
      }, {
        key: "tsParseModuleBlock",
        value: function tsParseModuleBlock() {
          var node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(types$1.braceL);
          this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types$1.braceR);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
      }, {
        key: "tsParseModuleOrNamespaceDeclaration",
        value: function tsParseModuleOrNamespaceDeclaration(node) {
          var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          node.id = this.parseIdentifier();

          if (!nested) {
            this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
          }

          if (this.eat(types$1.dot)) {
            var inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseAmbientExternalModuleDeclaration",
        value: function tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual("global")) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(types$1.string)) {
            node.id = this.parseExprAtom();
          } else {
            this.unexpected();
          }

          if (this.match(types$1.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }

          return this.finishNode(node, "TSModuleDeclaration");
        }
      }, {
        key: "tsParseImportEqualsDeclaration",
        value: function tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
          this.expect(types$1.eq);
          var moduleReference = this.tsParseModuleReference();

          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
          }

          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
      }, {
        key: "tsIsExternalModuleReference",
        value: function tsIsExternalModuleReference() {
          return this.isContextual("require") && this.lookaheadCharCode() === 40;
        }
      }, {
        key: "tsParseModuleReference",
        value: function tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
      }, {
        key: "tsParseExternalModuleReference",
        value: function tsParseExternalModuleReference() {
          var node = this.startNode();
          this.expectContextual("require");
          this.expect(types$1.parenL);

          if (!this.match(types$1.string)) {
            throw this.unexpected();
          }

          node.expression = this.parseExprAtom();
          this.expect(types$1.parenR);
          return this.finishNode(node, "TSExternalModuleReference");
        }
      }, {
        key: "tsLookAhead",
        value: function tsLookAhead(f) {
          var state = this.state.clone();
          var res = f();
          this.state = state;
          return res;
        }
      }, {
        key: "tsTryParseAndCatch",
        value: function tsTryParseAndCatch(f) {
          var result = this.tryParse(function (abort) {
            return f() || abort();
          });
          if (result.aborted || !result.node) return undefined;
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "tsTryParse",
        value: function tsTryParse(f) {
          var state = this.state.clone();
          var result = f();

          if (result !== undefined && result !== false) {
            return result;
          } else {
            this.state = state;
            return undefined;
          }
        }
      }, {
        key: "tsTryParseDeclare",
        value: function tsTryParseDeclare(nany) {
          var _this34 = this;

          if (this.isLineTerminator()) {
            return;
          }

          var starttype = this.state.type;
          var kind;

          if (this.isContextual("let")) {
            starttype = types$1._var;
            kind = "let";
          }

          return this.tsInAmbientContext(function () {
            switch (starttype) {
              case types$1._function:
                nany.declare = true;
                return _this34.parseFunctionStatement(nany, false, true);

              case types$1._class:
                nany.declare = true;
                return _this34.parseClass(nany, true, false);

              case types$1._const:
                if (_this34.match(types$1._const) && _this34.isLookaheadContextual("enum")) {
                  _this34.expect(types$1._const);

                  _this34.expectContextual("enum");

                  return _this34.tsParseEnumDeclaration(nany, true);
                }

              case types$1._var:
                kind = kind || _this34.state.value;
                return _this34.parseVarStatement(nany, kind);

              case types$1.name:
                {
                  var value = _this34.state.value;

                  if (value === "global") {
                    return _this34.tsParseAmbientExternalModuleDeclaration(nany);
                  } else {
                    return _this34.tsParseDeclaration(nany, value, true);
                  }
                }
            }
          });
        }
      }, {
        key: "tsTryParseExportDeclaration",
        value: function tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
      }, {
        key: "tsParseExpressionStatement",
        value: function tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare":
              {
                var declaration = this.tsTryParseDeclare(node);

                if (declaration) {
                  declaration.declare = true;
                  return declaration;
                }

                break;
              }

            case "global":
              if (this.match(types$1.braceL)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                var mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }

              break;

            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
      }, {
        key: "tsParseDeclaration",
        value: function tsParseDeclaration(node, value, next) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
                return this.tsParseAbstractDeclaration(node);
              }

              break;

            case "enum":
              if (next || this.match(types$1.name)) {
                if (next) this.next();
                return this.tsParseEnumDeclaration(node, false);
              }

              break;

            case "interface":
              if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                return this.tsParseInterfaceDeclaration(node);
              }

              break;

            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(types$1.string)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (this.match(types$1.name)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }

              break;

            case "namespace":
              if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }

              break;

            case "type":
              if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
                return this.tsParseTypeAliasDeclaration(node);
              }

              break;
          }
        }
      }, {
        key: "tsCheckLineTerminator",
        value: function tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak()) return false;
            this.next();
            return true;
          }

          return !this.isLineTerminator();
        }
      }, {
        key: "tsTryParseGenericAsyncArrowFunction",
        value: function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          var _this35 = this;

          if (!this.isRelational("<")) {
            return undefined;
          }

          var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          var res = this.tsTryParseAndCatch(function () {
            var node = _this35.startNodeAt(startPos, startLoc);

            node.typeParameters = _this35.tsParseTypeParameters();

            _get(_getPrototypeOf(_class4.prototype), "parseFunctionParams", _this35).call(_this35, node);

            node.returnType = _this35.tsTryParseTypeOrTypePredicateAnnotation();

            _this35.expect(types$1.arrow);

            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

          if (!res) {
            return undefined;
          }

          return this.parseArrowExpression(res, null, true);
        }
      }, {
        key: "tsParseTypeArguments",
        value: function tsParseTypeArguments() {
          var _this36 = this;

          var node = this.startNode();
          node.params = this.tsInType(function () {
            return _this36.tsInNoContext(function () {
              _this36.expectRelational("<");

              return _this36.tsParseDelimitedList("TypeParametersOrArguments", _this36.tsParseType.bind(_this36));
            });
          });

          if (node.params.length === 0) {
            this.raise(node.start, TSErrors.EmptyTypeArguments);
          }

          this.expectRelational(">");
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
      }, {
        key: "tsIsDeclarationStart",
        value: function tsIsDeclarationStart() {
          if (this.match(types$1.name)) {
            switch (this.state.value) {
              case "abstract":
              case "declare":
              case "enum":
              case "interface":
              case "module":
              case "namespace":
              case "type":
                return true;
            }
          }

          return false;
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart()) return false;
          return _get(_getPrototypeOf(_class4.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "parseAssignableListItem",
        value: function parseAssignableListItem(allowModifiers, decorators) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var accessibility;
          var readonly = false;
          var override = false;

          if (allowModifiers !== undefined) {
            var modified = {};
            this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;

            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(startPos, TSErrors.UnexpectedParameterModifier);
            }
          }

          var left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

          if (accessibility || readonly || override) {
            var pp = this.startNodeAt(startPos, startLoc);

            if (decorators.length) {
              pp.decorators = decorators;
            }

            if (accessibility) pp.accessibility = accessibility;
            if (readonly) pp.readonly = readonly;
            if (override) pp.override = override;

            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
            }

            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }

          if (decorators.length) {
            left.decorators = decorators;
          }

          return elt;
        }
      }, {
        key: "parseFunctionBodyAndFinish",
        value: function parseFunctionBodyAndFinish(node, type) {
          var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (this.match(types$1.colon)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
          }

          var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

          if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
            this.finishNode(node, bodilessType);
            return;
          }

          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

            if (node.declare) {
              _get(_getPrototypeOf(_class4.prototype), "parseFunctionBodyAndFinish", this).call(this, node, bodilessType, isMethod);

              return;
            }
          }

          _get(_getPrototypeOf(_class4.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
        }
      }, {
        key: "registerFunctionStatementId",
        value: function registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
          } else {
            _get(_getPrototypeOf(_class4.prototype), "registerFunctionStatementId", this).apply(this, arguments);
          }
        }
      }, {
        key: "tsCheckForInvalidTypeCasts",
        value: function tsCheckForInvalidTypeCasts(items) {
          var _this37 = this;

          items.forEach(function (node) {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              _this37.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
            }
          });
        }
      }, {
        key: "toReferencedList",
        value: function toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
      }, {
        key: "parseArrayLike",
        value: function parseArrayLike() {
          var _get8;

          for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
            args[_key13] = arguments[_key13];
          }

          var node = (_get8 = _get(_getPrototypeOf(_class4.prototype), "parseArrayLike", this)).call.apply(_get8, [this].concat(args));

          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }

          return node;
        }
      }, {
        key: "parseSubscript",
        value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
          var _this38 = this;

          if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
            this.state.exprAllowed = false;
            this.next();
            var nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }

          var isOptionalCall = false;

          if (this.match(types$1.questionDot) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }

            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }

          if (this.isRelational("<")) {
            var missingParenErrorPos;
            var result = this.tsTryParseAndCatch(function () {
              if (!noCalls && _this38.atPossibleAsyncArrow(base)) {
                var asyncArrowFn = _this38.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }

              var node = _this38.startNodeAt(startPos, startLoc);

              node.callee = base;

              var typeArguments = _this38.tsParseTypeArguments();

              if (typeArguments) {
                if (isOptionalCall && !_this38.match(types$1.parenL)) {
                  missingParenErrorPos = _this38.state.pos;

                  _this38.unexpected();
                }

                if (!noCalls && _this38.eat(types$1.parenL)) {
                  node.arguments = _this38.parseCallExpressionArguments(types$1.parenR, false);

                  _this38.tsCheckForInvalidTypeCasts(node.arguments);

                  node.typeParameters = typeArguments;

                  if (state.optionalChainMember) {
                    node.optional = isOptionalCall;
                  }

                  return _this38.finishCallExpression(node, state.optionalChainMember);
                } else if (_this38.match(types$1.backQuote)) {
                  var _result = _this38.parseTaggedTemplateExpression(base, startPos, startLoc, state);

                  _result.typeParameters = typeArguments;
                  return _result;
                }
              }

              _this38.unexpected();
            });

            if (missingParenErrorPos) {
              this.unexpected(missingParenErrorPos, types$1.parenL);
            }

            if (result) return result;
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseSubscript", this).call(this, base, startPos, startLoc, noCalls, state);
        }
      }, {
        key: "parseNewArguments",
        value: function parseNewArguments(node) {
          var _this39 = this;

          if (this.isRelational("<")) {
            var typeParameters = this.tsTryParseAndCatch(function () {
              var args = _this39.tsParseTypeArguments();

              if (!_this39.match(types$1.parenL)) _this39.unexpected();
              return args;
            });

            if (typeParameters) {
              node.typeParameters = typeParameters;
            }
          }

          _get(_getPrototypeOf(_class4.prototype), "parseNewArguments", this).call(this, node);
        }
      }, {
        key: "parseExprOp",
        value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
            var node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;

            var _const = this.tsTryNextParseConstantContext();

            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }

            this.finishNode(node, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseExprOp", this).call(this, left, leftStartPos, leftStartLoc, minPrec);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {}
      }, {
        key: "checkDuplicateExports",
        value: function checkDuplicateExports() {}
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          node.importKind = "value";

          if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
            var ahead = this.lookahead();

            if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }

            if (this.match(types$1.name) && ahead.type === types$1.eq) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }

          var importNode = _get(_getPrototypeOf(_class4.prototype), "parseImport", this).call(this, node);

          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
          }

          return importNode;
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          if (this.match(types$1._import)) {
            this.next();

            if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }

            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(types$1.eq)) {
            var assign = node;
            assign.expression = this.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual("as")) {
            var decl = node;
            this.expectContextual("namespace");
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }

            return _get(_getPrototypeOf(_class4.prototype), "parseExport", this).call(this, node);
          }
        }
      }, {
        key: "isAbstractClass",
        value: function isAbstractClass() {
          return this.isContextual("abstract") && this.lookahead().type === types$1._class;
        }
      }, {
        key: "parseExportDefaultExpression",
        value: function parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            var cls = this.startNode();
            this.next();
            cls["abstract"] = true;
            this.parseClass(cls, true, true);
            return cls;
          }

          if (this.state.value === "interface") {
            var interfaceNode = this.startNode();
            this.next();
            var result = this.tsParseInterfaceDeclaration(interfaceNode);
            if (result) return result;
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseExportDefaultExpression", this).call(this);
        }
      }, {
        key: "parseStatementContent",
        value: function parseStatementContent(context, topLevel) {
          if (this.state.type === types$1._const) {
            var ahead = this.lookahead();

            if (ahead.type === types$1.name && ahead.value === "enum") {
              var node = this.startNode();
              this.expect(types$1._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(node, true);
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseStatementContent", this).call(this, context, topLevel);
        }
      }, {
        key: "parseAccessModifier",
        value: function parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
      }, {
        key: "tsHasSomeModifiers",
        value: function tsHasSomeModifiers(member, modifiers) {
          return modifiers.some(function (modifier) {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }

            return !!member[modifier];
          });
        }
      }, {
        key: "parseClassMember",
        value: function parseClassMember(classBody, member, state) {
          var _this40 = this;

          var invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
          this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));

          var callParseClassMemberWithIsStatic = function callParseClassMemberWithIsStatic() {
            var isStatic = !!member["static"];

            if (isStatic && _this40.eat(types$1.braceL)) {
              if (_this40.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
                _this40.raise(_this40.state.pos, TSErrors.StaticBlockCannotHaveModifier);
              }

              _this40.parseClassStaticBlock(classBody, member);
            } else {
              _this40.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
            }
          };

          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
      }, {
        key: "parseClassMemberWithIsStatic",
        value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          var idx = this.tsTryParseIndexSignature(member);

          if (idx) {
            classBody.body.push(idx);

            if (member["abstract"]) {
              this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
            }

            if (member.accessibility) {
              this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
            }

            if (member.declare) {
              this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
            }

            if (member.override) {
              this.raise(member.start, TSErrors.IndexSignatureHasOverride);
            }

            return;
          }

          if (!this.state.inAbstractClass && member["abstract"]) {
            this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
          }

          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(member.start, TSErrors.OverrideNotInSubClass);
            }
          }

          _get(_getPrototypeOf(_class4.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody, member, state, isStatic);
        }
      }, {
        key: "parsePostMemberNameModifiers",
        value: function parsePostMemberNameModifiers(methodOrProp) {
          var optional = this.eat(types$1.question);
          if (optional) methodOrProp.optional = true;

          if (methodOrProp.readonly && this.match(types$1.parenL)) {
            this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
          }

          if (methodOrProp.declare && this.match(types$1.parenL)) {
            this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
          }
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
          return decl || _get(_getPrototypeOf(_class4.prototype), "parseExpressionStatement", this).call(this, node, expr);
        }
      }, {
        key: "shouldParseExportDeclaration",
        value: function shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart()) return true;
          return _get(_getPrototypeOf(_class4.prototype), "shouldParseExportDeclaration", this).call(this);
        }
      }, {
        key: "parseConditional",
        value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          var _this41 = this;

          if (!this.state.maybeInArrowParameters || !this.match(types$1.question)) {
            return _get(_getPrototypeOf(_class4.prototype), "parseConditional", this).call(this, expr, startPos, startLoc, refExpressionErrors);
          }

          var result = this.tryParse(function () {
            return _get(_getPrototypeOf(_class4.prototype), "parseConditional", _this41).call(_this41, expr, startPos, startLoc);
          });

          if (!result.node) {
            if (result.error) {
              _get(_getPrototypeOf(_class4.prototype), "setOptionalParametersError", this).call(this, refExpressionErrors, result.error);
            }

            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }
      }, {
        key: "parseParenItem",
        value: function parseParenItem(node, startPos, startLoc) {
          node = _get(_getPrototypeOf(_class4.prototype), "parseParenItem", this).call(this, node, startPos, startLoc);

          if (this.eat(types$1.question)) {
            node.optional = true;
            this.resetEndLocation(node);
          }

          if (this.match(types$1.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }

          return node;
        }
      }, {
        key: "parseExportDeclaration",
        value: function parseExportDeclaration(node) {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var isDeclare = this.eatContextual("declare");

          if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
            throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
          }

          var declaration;

          if (this.match(types$1.name)) {
            declaration = this.tsTryParseExportDeclaration();
          }

          if (!declaration) {
            declaration = _get(_getPrototypeOf(_class4.prototype), "parseExportDeclaration", this).call(this, node);
          }

          if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
            node.exportKind = "type";
          }

          if (declaration && isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }

          return declaration;
        }
      }, {
        key: "parseClassId",
        value: function parseClassId(node, isStatement, optionalId) {
          if ((!isStatement || optionalId) && this.isContextual("implements")) {
            return;
          }

          _get(_getPrototypeOf(_class4.prototype), "parseClassId", this).call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;
        }
      }, {
        key: "parseClassPropertyAnnotation",
        value: function parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(types$1.bang)) {
            node.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
        }
      }, {
        key: "parseClassProperty",
        value: function parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);

          if (this.state.isAmbientContext && this.match(types$1.eq)) {
            this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
          }

          if (node["abstract"] && this.match(types$1.eq)) {
            var key = node.key;
            this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, key.type === "Identifier" && !node.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]"));
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseClassProperty", this).call(this, node);
        }
      }, {
        key: "parseClassPrivateProperty",
        value: function parseClassPrivateProperty(node) {
          if (node["abstract"]) {
            this.raise(node.start, TSErrors.PrivateElementHasAbstract);
          }

          if (node.accessibility) {
            this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
          }

          this.parseClassPropertyAnnotation(node);
          return _get(_getPrototypeOf(_class4.prototype), "parseClassPrivateProperty", this).call(this, node);
        }
      }, {
        key: "pushClassMethod",
        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          var typeParameters = this.tsTryParseTypeParameters();

          if (typeParameters && isConstructor) {
            this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
          }

          if (method.declare && (method.kind === "get" || method.kind === "set")) {
            this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
          }

          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
      }, {
        key: "pushClassPrivateMethod",
        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
        }
      }, {
        key: "parseClassSuper",
        value: function parseClassSuper(node) {
          _get(_getPrototypeOf(_class4.prototype), "parseClassSuper", this).call(this, node);

          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.tsParseTypeArguments();
          }

          if (this.eatContextual("implements")) {
            node["implements"] = this.tsParseHeritageClause("implements");
          }
        }
      }, {
        key: "parseObjPropValue",
        value: function parseObjPropValue(prop) {
          var _get9;

          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) prop.typeParameters = typeParameters;

          for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
            args[_key14 - 1] = arguments[_key14];
          }

          (_get9 = _get(_getPrototypeOf(_class4.prototype), "parseObjPropValue", this)).call.apply(_get9, [this, prop].concat(args));
        }
      }, {
        key: "parseFunctionParams",
        value: function parseFunctionParams(node, allowModifiers) {
          var typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;

          _get(_getPrototypeOf(_class4.prototype), "parseFunctionParams", this).call(this, node, allowModifiers);
        }
      }, {
        key: "parseVarId",
        value: function parseVarId(decl, kind) {
          _get(_getPrototypeOf(_class4.prototype), "parseVarId", this).call(this, decl, kind);

          if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
            decl.definite = true;
          }

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
      }, {
        key: "parseAsyncArrowFromCallExpression",
        value: function parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(types$1.colon)) {
            node.returnType = this.tsParseTypeAnnotation();
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
        }
      }, {
        key: "parseMaybeAssign",
        value: function parseMaybeAssign() {
          var _this42 = this;

          for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
            args[_key15] = arguments[_key15];
          }

          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

          var state;
          var jsx;
          var typeCast;

          if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
            state = this.state.clone();
            jsx = this.tryParse(function () {
              var _get10;

              return (_get10 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this42)).call.apply(_get10, [_this42].concat(args));
            }, state);
            if (!jsx.error) return jsx.node;
            var context = this.state.context;

            if (context[context.length - 1] === types.j_oTag) {
              context.length -= 2;
            } else if (context[context.length - 1] === types.j_expr) {
              context.length -= 1;
            }
          }

          if (!((_jsx = jsx) != null && _jsx.error) && !this.isRelational("<")) {
            var _get11;

            return (_get11 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", this)).call.apply(_get11, [this].concat(args));
          }

          var typeParameters;
          state = state || this.state.clone();
          var arrow = this.tryParse(function (abort) {
            var _get12;

            var _expr$extra, _typeParameters;

            typeParameters = _this42.tsParseTypeParameters();

            var expr = (_get12 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this42)).call.apply(_get12, [_this42].concat(args));

            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }

            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              _this42.resetStartLocationFromNode(expr, typeParameters);
            }

            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;

          if (!jsx) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(function () {
              var _get13;

              return (_get13 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeAssign", _this42)).call.apply(_get13, [_this42].concat(args));
            }, state);
            if (!typeCast.error) return typeCast.node;
          }

          if ((_jsx2 = jsx) != null && _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }

          if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
          throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
      }, {
        key: "parseMaybeUnary",
        value: function parseMaybeUnary(refExpressionErrors) {
          if (!this.hasPlugin("jsx") && this.isRelational("<")) {
            return this.tsParseTypeAssertion();
          } else {
            return _get(_getPrototypeOf(_class4.prototype), "parseMaybeUnary", this).call(this, refExpressionErrors);
          }
        }
      }, {
        key: "parseArrow",
        value: function parseArrow(node) {
          var _this43 = this;

          if (this.match(types$1.colon)) {
            var result = this.tryParse(function (abort) {
              var returnType = _this43.tsParseTypeOrTypePredicateAnnotation(types$1.colon);

              if (_this43.canInsertSemicolon() || !_this43.match(types$1.arrow)) abort();
              return returnType;
            });
            if (result.aborted) return;

            if (!result.thrown) {
              if (result.error) this.state = result.failState;
              node.returnType = result.node;
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseArrow", this).call(this, node);
        }
      }, {
        key: "parseAssignableListItemTypes",
        value: function parseAssignableListItemTypes(param) {
          if (this.eat(types$1.question)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(param.start, TSErrors.PatternIsOptional);
            }

            param.optional = true;
          }

          var type = this.tsTryParseTypeAnnotation();
          if (type) param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
      }, {
        key: "isAssignable",
        value: function isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);

            case "TSParameterProperty":
              return true;

            default:
              return _get(_getPrototypeOf(_class4.prototype), "isAssignable", this).call(this, node, isBinding);
          }
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          switch (node.type) {
            case "TSTypeCastExpression":
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, this.typeCastToParameter(node), isLHS);

            case "TSParameterProperty":
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, node, isLHS);

            case "ParenthesizedExpression":
              return this.toAssignableParenthesizedExpression(node, isLHS);

            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              node.expression = this.toAssignable(node.expression, isLHS);
              return node;

            default:
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, node, isLHS);
          }
        }
      }, {
        key: "toAssignableParenthesizedExpression",
        value: function toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              node.expression = this.toAssignable(node.expression, isLHS);
              return node;

            default:
              return _get(_getPrototypeOf(_class4.prototype), "toAssignable", this).call(this, node, isLHS);
          }
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr, contextDescription) {
          var _get14;

          var _expr$extra2;

          for (var _len16 = arguments.length, args = new Array(_len16 > 2 ? _len16 - 2 : 0), _key16 = 2; _key16 < _len16; _key16++) {
            args[_key16 - 2] = arguments[_key16];
          }

          switch (expr.type) {
            case "TSTypeCastExpression":
              return;

            case "TSParameterProperty":
              this.checkLVal.apply(this, [expr.parameter, "parameter property"].concat(args));
              return;

            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
                this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
                break;
              }

              this.checkLVal.apply(this, [expr.expression, "parenthesized expression"].concat(args));
              return;

            case "TSNonNullExpression":
              this.checkLVal.apply(this, [expr.expression, contextDescription].concat(args));
              return;

            default:
              (_get14 = _get(_getPrototypeOf(_class4.prototype), "checkLVal", this)).call.apply(_get14, [this, expr, contextDescription].concat(args));

              return;
          }
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          switch (this.state.type) {
            case types$1._this:
              return this.parseIdentifier(true);

            default:
              return _get(_getPrototypeOf(_class4.prototype), "parseBindingAtom", this).call(this);
          }
        }
      }, {
        key: "parseMaybeDecoratorArguments",
        value: function parseMaybeDecoratorArguments(expr) {
          if (this.isRelational("<")) {
            var typeArguments = this.tsParseTypeArguments();

            if (this.match(types$1.parenL)) {
              var call = _get(_getPrototypeOf(_class4.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);

              call.typeParameters = typeArguments;
              return call;
            }

            this.unexpected(this.state.start, types$1.parenL);
          }

          return _get(_getPrototypeOf(_class4.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
        }
      }, {
        key: "checkCommaAfterRest",
        value: function checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
            this.next();
          } else {
            _get(_getPrototypeOf(_class4.prototype), "checkCommaAfterRest", this).call(this, close);
          }
        }
      }, {
        key: "isClassMethod",
        value: function isClassMethod() {
          return this.isRelational("<") || _get(_getPrototypeOf(_class4.prototype), "isClassMethod", this).call(this);
        }
      }, {
        key: "isClassProperty",
        value: function isClassProperty() {
          return this.match(types$1.bang) || this.match(types$1.colon) || _get(_getPrototypeOf(_class4.prototype), "isClassProperty", this).call(this);
        }
      }, {
        key: "parseMaybeDefault",
        value: function parseMaybeDefault() {
          var _get15;

          for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
            args[_key17] = arguments[_key17];
          }

          var node = (_get15 = _get(_getPrototypeOf(_class4.prototype), "parseMaybeDefault", this)).call.apply(_get15, [this].concat(args));

          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
          }

          return node;
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types$1.relational, 1);
          } else {
            return _get(_getPrototypeOf(_class4.prototype), "getTokenFromCode", this).call(this, code);
          }
        }
      }, {
        key: "reScan_lt_gt",
        value: function reScan_lt_gt() {
          if (this.match(types$1.relational)) {
            var code = this.input.charCodeAt(this.state.start);

            if (code === 60 || code === 62) {
              this.state.pos -= 1;
              this.readToken_lt_gt(code);
            }
          }
        }
      }, {
        key: "toAssignableList",
        value: function toAssignableList(exprList) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];
            if (!expr) continue;

            switch (expr.type) {
              case "TSTypeCastExpression":
                exprList[i] = this.typeCastToParameter(expr);
                break;

              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!this.state.maybeInArrowParameters) {
                  exprList[i] = this.typeCastToParameter(expr);
                } else {
                  this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
                }

                break;
            }
          }

          return _get(_getPrototypeOf(_class4.prototype), "toAssignableList", this).apply(this, arguments);
        }
      }, {
        key: "typeCastToParameter",
        value: function typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
          return node.expression;
        }
      }, {
        key: "shouldParseArrow",
        value: function shouldParseArrow(params) {
          var _this44 = this;

          if (this.match(types$1.colon)) {
            return params.every(function (expr) {
              return _this44.isAssignable(expr, true);
            });
          }

          return _get(_getPrototypeOf(_class4.prototype), "shouldParseArrow", this).call(this, params);
        }
      }, {
        key: "shouldParseAsyncArrow",
        value: function shouldParseAsyncArrow() {
          return this.match(types$1.colon) || _get(_getPrototypeOf(_class4.prototype), "shouldParseAsyncArrow", this).call(this);
        }
      }, {
        key: "canHaveLeadingDecorator",
        value: function canHaveLeadingDecorator() {
          return _get(_getPrototypeOf(_class4.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
        }
      }, {
        key: "jsxParseOpeningElementAfterName",
        value: function jsxParseOpeningElementAfterName(node) {
          var _this45 = this;

          if (this.isRelational("<")) {
            var typeArguments = this.tsTryParseAndCatch(function () {
              return _this45.tsParseTypeArguments();
            });
            if (typeArguments) node.typeParameters = typeArguments;
          }

          return _get(_getPrototypeOf(_class4.prototype), "jsxParseOpeningElementAfterName", this).call(this, node);
        }
      }, {
        key: "getGetterSetterExpectedParamCount",
        value: function getGetterSetterExpectedParamCount(method) {
          var baseCount = _get(_getPrototypeOf(_class4.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);

          var params = this.getObjectOrClassMethodParams(method);
          var firstParam = params[0];
          var hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
      }, {
        key: "parseCatchClauseParam",
        value: function parseCatchClauseParam() {
          var param = _get(_getPrototypeOf(_class4.prototype), "parseCatchClauseParam", this).call(this);

          var type = this.tsTryParseTypeAnnotation();

          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }

          return param;
        }
      }, {
        key: "tsInAmbientContext",
        value: function tsInAmbientContext(cb) {
          var oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;

          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
      }, {
        key: "parseClass",
        value: function parseClass(node) {
          var oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node["abstract"];

          try {
            var _get16;

            for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {
              args[_key18 - 1] = arguments[_key18];
            }

            return (_get16 = _get(_getPrototypeOf(_class4.prototype), "parseClass", this)).call.apply(_get16, [this, node].concat(args));
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
      }, {
        key: "tsParseAbstractDeclaration",
        value: function tsParseAbstractDeclaration(node) {
          if (this.match(types$1._class)) {
            node["abstract"] = true;
            return this.parseClass(node, true, false);
          } else if (this.isContextual("interface")) {
            if (!this.hasFollowingLineBreak()) {
              node["abstract"] = true;
              this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
              this.next();
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, types$1._class);
          }
        }
      }, {
        key: "parseMethod",
        value: function parseMethod() {
          var _get17;

          for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
            args[_key19] = arguments[_key19];
          }

          var method = (_get17 = _get(_getPrototypeOf(_class4.prototype), "parseMethod", this)).call.apply(_get17, [this].concat(args));

          if (method["abstract"]) {
            var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

            if (hasBody) {
              var key = method.key;
              this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" && !method.computed ? key.name : "[".concat(this.input.slice(key.start, key.end), "]"));
            }
          }

          return method;
        }
      }, {
        key: "tsParseTypeParameterName",
        value: function tsParseTypeParameterName() {
          var typeName = this.parseIdentifier();
          return typeName.name;
        }
      }, {
        key: "shouldParseAsAmbientContext",
        value: function shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
      }, {
        key: "parse",
        value: function parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }

          return _get(_getPrototypeOf(_class4.prototype), "parse", this).call(this);
        }
      }, {
        key: "getExpression",
        value: function getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }

          return _get(_getPrototypeOf(_class4.prototype), "getExpression", this).call(this);
        }
      }]);

      return _class4;
    }(superClass)
  );
};

types$1.placeholder = new TokenType("%%", {
  startsExpr: true
});
var PlaceHolderErrors = makeErrorTemplates({
  ClassNameIsRequired: "A class name is required."
}, ErrorCodes.SyntaxError);

var placeholders = function placeholders(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass5) {
      _inherits(_class5, _superClass5);

      function _class5() {
        _classCallCheck(this, _class5);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class5).apply(this, arguments));
      }

      _createClass(_class5, [{
        key: "parsePlaceholder",
        value: function parsePlaceholder(expectedNode) {
          if (this.match(types$1.placeholder)) {
            var node = this.startNode();
            this.next();
            this.assertNoSpace("Unexpected space in placeholder.");
            node.name = _get(_getPrototypeOf(_class5.prototype), "parseIdentifier", this).call(this, true);
            this.assertNoSpace("Unexpected space in placeholder.");
            this.expect(types$1.placeholder);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
      }, {
        key: "finishPlaceholder",
        value: function finishPlaceholder(node, expectedNode) {
          var isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
      }, {
        key: "getTokenFromCode",
        value: function getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(types$1.placeholder, 2);
          }

          return _get(_getPrototypeOf(_class5.prototype), "getTokenFromCode", this).apply(this, arguments);
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom() {
          return this.parsePlaceholder("Expression") || _get(_getPrototypeOf(_class5.prototype), "parseExprAtom", this).apply(this, arguments);
        }
      }, {
        key: "parseIdentifier",
        value: function parseIdentifier() {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(_class5.prototype), "parseIdentifier", this).apply(this, arguments);
        }
      }, {
        key: "checkReservedWord",
        value: function checkReservedWord(word) {
          if (word !== undefined) _get(_getPrototypeOf(_class5.prototype), "checkReservedWord", this).apply(this, arguments);
        }
      }, {
        key: "parseBindingAtom",
        value: function parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || _get(_getPrototypeOf(_class5.prototype), "parseBindingAtom", this).apply(this, arguments);
        }
      }, {
        key: "checkLVal",
        value: function checkLVal(expr) {
          if (expr.type !== "Placeholder") _get(_getPrototypeOf(_class5.prototype), "checkLVal", this).apply(this, arguments);
        }
      }, {
        key: "toAssignable",
        value: function toAssignable(node) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
            return node;
          }

          return _get(_getPrototypeOf(_class5.prototype), "toAssignable", this).apply(this, arguments);
        }
      }, {
        key: "isLet",
        value: function isLet(context) {
          if (_get(_getPrototypeOf(_class5.prototype), "isLet", this).call(this, context)) {
            return true;
          }

          if (!this.isContextual("let")) {
            return false;
          }

          if (context) return false;
          var nextToken = this.lookahead();

          if (nextToken.type === types$1.placeholder) {
            return true;
          }

          return false;
        }
      }, {
        key: "verifyBreakContinue",
        value: function verifyBreakContinue(node) {
          if (node.label && node.label.type === "Placeholder") return;

          _get(_getPrototypeOf(_class5.prototype), "verifyBreakContinue", this).apply(this, arguments);
        }
      }, {
        key: "parseExpressionStatement",
        value: function parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return _get(_getPrototypeOf(_class5.prototype), "parseExpressionStatement", this).apply(this, arguments);
          }

          if (this.match(types$1.colon)) {
            var stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = this.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }

          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
      }, {
        key: "parseBlock",
        value: function parseBlock() {
          return this.parsePlaceholder("BlockStatement") || _get(_getPrototypeOf(_class5.prototype), "parseBlock", this).apply(this, arguments);
        }
      }, {
        key: "parseFunctionId",
        value: function parseFunctionId() {
          return this.parsePlaceholder("Identifier") || _get(_getPrototypeOf(_class5.prototype), "parseFunctionId", this).apply(this, arguments);
        }
      }, {
        key: "parseClass",
        value: function parseClass(node, isStatement, optionalId) {
          var type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          var oldStrict = this.state.strict;
          var placeholder = this.parsePlaceholder("Identifier");

          if (placeholder) {
            if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }

          this.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
      }, {
        key: "parseExport",
        value: function parseExport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(_class5.prototype), "parseExport", this).apply(this, arguments);

          if (!this.isContextual("from") && !this.match(types$1.comma)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }

          this.expectPlugin("exportDefaultFrom");
          var specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return _get(_getPrototypeOf(_class5.prototype), "parseExport", this).call(this, node);
        }
      }, {
        key: "isExportDefaultSpecifier",
        value: function isExportDefaultSpecifier() {
          if (this.match(types$1._default)) {
            var next = this.nextTokenStart();

            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }

          return _get(_getPrototypeOf(_class5.prototype), "isExportDefaultSpecifier", this).call(this);
        }
      }, {
        key: "maybeParseExportDefaultSpecifier",
        value: function maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }

          return _get(_getPrototypeOf(_class5.prototype), "maybeParseExportDefaultSpecifier", this).apply(this, arguments);
        }
      }, {
        key: "checkExport",
        value: function checkExport(node) {
          var specifiers = node.specifiers;

          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter(function (node) {
              return node.exported.type === "Placeholder";
            });
          }

          _get(_getPrototypeOf(_class5.prototype), "checkExport", this).call(this, node);

          node.specifiers = specifiers;
        }
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          var placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return _get(_getPrototypeOf(_class5.prototype), "parseImport", this).apply(this, arguments);
          node.specifiers = [];

          if (!this.isContextual("from") && !this.match(types$1.comma)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }

          var specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          this.finishNode(specifier, "ImportDefaultSpecifier");
          node.specifiers.push(specifier);

          if (this.eat(types$1.comma)) {
            var hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport) this.parseNamedImportSpecifiers(node);
          }

          this.expectContextual("from");
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
      }, {
        key: "parseImportSource",
        value: function parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || _get(_getPrototypeOf(_class5.prototype), "parseImportSource", this).apply(this, arguments);
        }
      }]);

      return _class5;
    }(superClass)
  );
};

var v8intrinsic = function v8intrinsic(superClass) {
  return (
    /*#__PURE__*/
    function (_superClass6) {
      _inherits(_class6, _superClass6);

      function _class6() {
        _classCallCheck(this, _class6);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class6).apply(this, arguments));
      }

      _createClass(_class6, [{
        key: "parseV8Intrinsic",
        value: function parseV8Intrinsic() {
          if (this.match(types$1.modulo)) {
            var v8IntrinsicStart = this.state.start;
            var node = this.startNode();
            this.eat(types$1.modulo);

            if (this.match(types$1.name)) {
              var name = this.parseIdentifierName(this.state.start);
              var identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";

              if (this.match(types$1.parenL)) {
                return identifier;
              }
            }

            this.unexpected(v8IntrinsicStart);
          }
        }
      }, {
        key: "parseExprAtom",
        value: function parseExprAtom() {
          return this.parseV8Intrinsic() || _get(_getPrototypeOf(_class6.prototype), "parseExprAtom", this).apply(this, arguments);
        }
      }]);

      return _class6;
    }(superClass)
  );
};

function hasPlugin(plugins, name) {
  return plugins.some(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}

function getPluginOption(plugins, name, option) {
  var plugin = plugins.find(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }

  return null;
}

var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
var TOPIC_TOKENS = ["%", "#"];
var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];

function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport == null) {
      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator")) {
    var proposal = getPluginOption(plugins, "pipelineOperator", "proposal");

    if (!PIPELINE_PROPOSALS.includes(proposal)) {
      var proposalList = PIPELINE_PROPOSALS.map(function (p) {
        return "\"".concat(p, "\"");
      }).join(", ");
      throw new Error("\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ".concat(proposalList, "."));
    }

    var tupleSyntaxIsHash = hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") === "hash";

    if (proposal === "hack") {
      if (hasPlugin(plugins, "placeholders")) {
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      }

      if (hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      }

      var topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");

      if (!TOPIC_TOKENS.includes(topicToken)) {
        var tokenList = TOPIC_TOKENS.map(function (t) {
          return "\"".concat(t, "\"");
        }).join(", ");
        throw new Error("\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ".concat(tokenList, "."));
      }

      if (topicToken === "#" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    } else if (proposal === "smart" && tupleSyntaxIsHash) {
      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
  }

  if (hasPlugin(plugins, "moduleAttributes")) {
    {
      if (hasPlugin(plugins, "importAssertions")) {
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      }

      var moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

      if (moduleAttributesVerionPluginOption !== "may-2020") {
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
      }
    }
  }

  if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
    throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
      return "'".concat(p, "'");
    }).join(", "));
  }

  if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
    var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    error.missingPlugins = "doExpressions";
    throw error;
  }
}

var mixinPlugins = {
  estree: estree,
  jsx: jsx,
  flow: flow,
  typescript: typescript,
  v8intrinsic: v8intrinsic,
  placeholders: placeholders
};
var mixinPluginNames = Object.keys(mixinPlugins);
var defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true
};

function getOptions(opts) {
  var options = {};

  for (var _i2 = 0, _Object$keys = Object.keys(defaultOptions); _i2 < _Object$keys.length; _i2++) {
    var key = _Object$keys[_i2];
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

var LValParser =
/*#__PURE__*/
function (_NodeUtils) {
  _inherits(LValParser, _NodeUtils);

  function LValParser() {
    _classCallCheck(this, LValParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(LValParser).apply(this, arguments));
  }

  _createClass(LValParser, [{
    key: "toAssignable",
    value: function toAssignable(node) {
      var isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _node$extra, _node$extra3;

      var parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            var prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value, isLHS);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            var arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }

      return node;
    }
  }, {
    key: "toAssignableObjectExpressionProp",
    value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
  }, {
    key: "toAssignableList",
    value: function toAssignableList(exprList, trailingCommaPos, isLHS) {
      var end = exprList.length;

      if (end) {
        var last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isLHS);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }
  }, {
    key: "isAssignable",
    value: function isAssignable(node, isBinding) {
      var _this46 = this;

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;

        case "ObjectExpression":
          {
            var last = node.properties.length - 1;
            return node.properties.every(function (prop, i) {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && _this46.isAssignable(prop);
            });
          }

        case "ObjectProperty":
          return this.isAssignable(node.value);

        case "SpreadElement":
          return this.isAssignable(node.argument);

        case "ArrayExpression":
          return node.elements.every(function (element) {
            return element === null || _this46.isAssignable(element);
          });

        case "AssignmentExpression":
          return node.operator === "=";

        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);

        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;

        default:
          return false;
      }
    }
  }, {
    key: "toReferencedList",
    value: function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
  }, {
    key: "toReferencedListDeep",
    value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = exprList[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var expr = _step6.value;

          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: "parseSpread",
    value: function parseSpread(refExpressionErrors, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }
  }, {
    key: "parseRestBinding",
    value: function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
  }, {
    key: "parseBindingAtom",
    value: function parseBindingAtom() {
      switch (this.state.type) {
        case types$1.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types$1.braceL:
          return this.parseObjectLike(types$1.braceR, true);
      }

      return this.parseIdentifier();
    }
  }, {
    key: "parseBindingList",
    value: function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }

        if (allowEmpty && this.match(types$1.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types$1.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types$1.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }

          while (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }
  }, {
    key: "parseAssignableListItem",
    value: function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }
  }, {
    key: "parseAssignableListItemTypes",
    value: function parseAssignableListItemTypes(param) {
      return param;
    }
  }, {
    key: "parseMaybeDefault",
    value: function parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types$1.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }
  }, {
    key: "checkLVal",
    value: function checkLVal(expr, contextDescription) {
      var bindingType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BIND_NONE;
      var checkClashes = arguments.length > 3 ? arguments[3] : undefined;
      var disallowLetBinding = arguments.length > 4 ? arguments[4] : undefined;
      var strictModeChanged = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      switch (expr.type) {
        case "Identifier":
          {
            var name = expr.name;

            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
            }

            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(expr.start, ErrorMessages.ParamDupe);
              } else {
                checkClashes.add(name);
              }
            }

            if (disallowLetBinding && name === "let") {
              this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
            }

            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.start);
            }

            break;
          }

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = expr.properties[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var prop = _step7.value;
              if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
              this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          break;

        case "ArrayPattern":
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = expr.elements[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var elem = _step8.value;

              if (elem) {
                this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
          break;

        case "RestElement":
          this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
      }
    }
  }, {
    key: "checkToRestConversion",
    value: function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    }
  }, {
    key: "checkCommaAfterRest",
    value: function checkCommaAfterRest(close) {
      if (this.match(types$1.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }
  }, {
    key: "raiseRestNotLast",
    value: function raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }
  }, {
    key: "raiseTrailingCommaAfterRest",
    value: function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }
  }]);

  return LValParser;
}(NodeUtils);

var ExpressionParser =
/*#__PURE__*/
function (_LValParser) {
  _inherits(ExpressionParser, _LValParser);

  function ExpressionParser() {
    _classCallCheck(this, ExpressionParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(ExpressionParser).apply(this, arguments));
  }

  _createClass(ExpressionParser, [{
    key: "checkProto",
    value: function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    }
  }, {
    key: "shouldExitDescending",
    value: function shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
  }, {
    key: "getExpression",
    value: function getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types$1.eof)) {
        this.unexpected();
      }

      this.finalizeRemainingComments();
      expr.comments = this.state.comments;
      expr.errors = this.state.errors;

      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }

      return expr;
    }
  }, {
    key: "parseExpression",
    value: function parseExpression(disallowIn, refExpressionErrors) {
      var _this47 = this;

      if (disallowIn) {
        return this.disallowInAnd(function () {
          return _this47.parseExpressionBase(refExpressionErrors);
        });
      }

      return this.allowInAnd(function () {
        return _this47.parseExpressionBase(refExpressionErrors);
      });
    }
  }, {
    key: "parseExpressionBase",
    value: function parseExpressionBase(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types$1.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }
  }, {
    key: "parseMaybeAssignDisallowIn",
    value: function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      var _this48 = this;

      return this.disallowInAnd(function () {
        return _this48.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    }
  }, {
    key: "parseMaybeAssignAllowIn",
    value: function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      var _this49 = this;

      return this.allowInAnd(function () {
        return _this49.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    }
  }, {
    key: "setOptionalParametersError",
    value: function setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$pos;

      refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
    }
  }, {
    key: "parseMaybeAssign",
    value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          var _left2 = this.parseYield();

          if (afterLeftParse) {
            _left2 = afterLeftParse.call(this, _left2, startPos, startLoc);
          }

          return _left2;
        }
      }

      var ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types$1.parenL) || this.match(types$1.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(refExpressionErrors);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;
        var leftIsHackPipeExpression = left.type === "BinaryExpression" && left.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack";

        if (leftIsHackPipeExpression) {
          throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, operator);
        }

        if (this.match(types$1.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    }
  }, {
    key: "parseMaybeConditional",
    value: function parseMaybeConditional(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
    }
  }, {
    key: "parseConditional",
    value: function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }
  }, {
    key: "parseExprOps",
    value: function parseExprOps(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    }
  }, {
    key: "parseExprOp",
    value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      var prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
        if (prec > minPrec) {
          var op = this.state.type;

          if (op === types$1.pipeline) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          var logical = op === types$1.logicalOR || op === types$1.logicalAND;
          var coalesce = op === types$1.nullishCoalescing;

          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }

          this.next();

          if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;

          if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    }
  }, {
    key: "parseExprOpRightExpr",
    value: function parseExprOpRightExpr(op, prec) {
      var _this50 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(function () {
                var bodyExpr = _this50.parseHackPipeBody(op, prec);

                _this50.checkHackPipeBodyEarlyErrors(startPos);

                return bodyExpr;
              });

            case "smart":
              return this.withTopicBindingContext(function () {
                var childExpr = _this50.parseHackPipeBody(op, prec);

                return _this50.parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this50.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
  }, {
    key: "parseExprOpBaseRightExpr",
    value: function parseExprOpBaseRightExpr(op, prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    }
  }, {
    key: "parseHackPipeBody",
    value: function parseHackPipeBody(op, prec) {
      var bodyIsInGeneratorContext = this.prodParam.hasYield;
      var bodyIsYieldExpression = bodyIsInGeneratorContext && this.isContextual("yield");

      if (bodyIsYieldExpression) {
        throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, this.state.value);
      } else {
        return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
  }, {
    key: "checkExponentialAfterUnary",
    value: function checkExponentialAfterUnary(node) {
      if (this.match(types$1.exponent)) {
        this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
      }
    }
  }, {
    key: "parseMaybeUnary",
    value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var isAwait = this.isContextual("await");

      if (isAwait && this.isAwaitAllowed()) {
        this.next();

        var _expr = this.parseAwait(startPos, startLoc);

        if (!sawUnary) this.checkExponentialAfterUnary(_expr);
        return _expr;
      }

      var update = this.match(types$1.incDec);
      var node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types$1._throw)) {
          this.expectPlugin("throwExpressions");
        }

        var isDelete = this.match(types$1._delete);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          if (!sawUnary) this.checkExponentialAfterUnary(node);
          return this.finishNode(node, "UnaryExpression");
        }
      }

      var expr = this.parseUpdate(node, update, refExpressionErrors);

      if (isAwait) {
        var _startsExpr = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);

        if (_startsExpr && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);
          return this.parseAwait(startPos, startLoc);
        }
      }

      return expr;
    }
  }, {
    key: "parseUpdate",
    value: function parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node9 = this.startNodeAt(startPos, startLoc);

        _node9.operator = this.state.value;
        _node9.prefix = false;
        _node9.argument = expr;
        this.checkLVal(expr, "postfix operation");
        this.next();
        expr = this.finishNode(_node9, "UpdateExpression");
      }

      return expr;
    }
  }, {
    key: "parseExprSubscripts",
    value: function parseExprSubscripts(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }
  }, {
    key: "parseSubscripts",
    value: function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }
  }, {
    key: "parseSubscript",
    value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types$1.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types$1.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      var optional = false;

      if (this.match(types$1.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(types$1.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    }
  }, {
    key: "parseMember",
    value: function parseMember(base, startPos, startLoc, state, optional) {
      var node = this.startNodeAt(startPos, startLoc);
      var computed = this.eat(types$1.bracketL);
      node.object = base;
      node.computed = computed;
      var privateName = !computed && this.match(types$1.privateName) && this.state.value;
      var property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);

      if (privateName !== false) {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(privateName, property.start);
      }

      node.property = property;

      if (computed) {
        this.expect(types$1.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }
  }, {
    key: "parseBind",
    value: function parseBind(base, startPos, startLoc, noCalls, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }
  }, {
    key: "parseCoverCallAndAsyncArrowHead",
    value: function parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR);
      } else {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
      } else {
        if (state.maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }

        this.toReferencedArguments(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
  }, {
    key: "toReferencedArguments",
    value: function toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
  }, {
    key: "parseTaggedTemplateExpression",
    value: function parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }
  }, {
    key: "atPossibleAsyncArrow",
    value: function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
  }, {
    key: "finishCallExpression",
    value: function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectPlugin("importAssertions");
            }
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = node.arguments[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var arg = _step9.value;

              if (arg.type === "SpreadElement") {
                this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
              }
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                _iterator9["return"]();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
  }, {
    key: "parseCallExpressionArguments",
    value: function parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      var elts = [];
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
  }, {
    key: "shouldParseAsyncArrow",
    value: function shouldParseAsyncArrow() {
      return this.match(types$1.arrow) && !this.canInsertSemicolon();
    }
  }, {
    key: "parseAsyncArrowFromCallExpression",
    value: function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.resetPreviousNodeTrailingComments(call);
      this.expect(types$1.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      setInnerComments(node, call.innerComments);
      setInnerComments(node, call.callee.trailingComments);
      return node;
    }
  }, {
    key: "parseNoCallExpr",
    value: function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
  }, {
    key: "parseExprAtom",
    value: function parseExprAtom(refExpressionErrors) {
      var node;

      switch (this.state.type) {
        case types$1._super:
          return this.parseSuper();

        case types$1._import:
          node = this.startNode();
          this.next();

          if (this.match(types$1.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types$1.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types$1.name:
          {
            if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
              return this.parseModuleExpression();
            }

            var canBeArrow = this.state.potentialArrowAt === this.state.start;
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types$1._function)) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (this.match(types$1.name)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (this.match(types$1._do)) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }

            if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          }

        case types$1._do:
          {
            return this.parseDo(this.startNode(), false);
          }

        case types$1.slash:
        case types$1.slashAssign:
          {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }

        case types$1.num:
          return this.parseNumericLiteral(this.state.value);

        case types$1.bigint:
          return this.parseBigIntLiteral(this.state.value);

        case types$1.decimal:
          return this.parseDecimalLiteral(this.state.value);

        case types$1.string:
          return this.parseStringLiteral(this.state.value);

        case types$1._null:
          return this.parseNullLiteral();

        case types$1._true:
          return this.parseBooleanLiteral(true);

        case types$1._false:
          return this.parseBooleanLiteral(false);

        case types$1.parenL:
          {
            var _canBeArrow = this.state.potentialArrowAt === this.state.start;

            return this.parseParenAndDistinguishExpression(_canBeArrow);
          }

        case types$1.bracketBarL:
        case types$1.bracketHashL:
          {
            return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
          }

        case types$1.bracketL:
          {
            return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
          }

        case types$1.braceBarL:
        case types$1.braceHashL:
          {
            return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
          }

        case types$1.braceL:
          {
            return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
          }

        case types$1._function:
          return this.parseFunctionOrFunctionSent();

        case types$1.at:
          this.parseDecorators();

        case types$1._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types$1._new:
          return this.parseNewOrNewTarget();

        case types$1.backQuote:
          return this.parseTemplate(false);

        case types$1.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }

        case types$1.privateName:
          {
            var _this$state3 = this.state,
                value = _this$state3.value,
                start = _this$state3.start;
            node = this.parsePrivateName();

            if (this.match(types$1._in)) {
              this.classScope.usePrivateName(value, start);
            } else {
              this.raise(start, ErrorMessages.PrivateInExpectedIn, value);
            }

            return node;
          }

        case types$1.moduloAssign:
          if (this.getPluginOption("pipelineOperator", "proposal") === "hack" && this.getPluginOption("pipelineOperator", "topicToken") === "%") {
            this.state.value = "%";
            this.state.type = types$1.modulo;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc.column--;
          } else {
            throw this.unexpected();
          }

        case types$1.modulo:
        case types$1.hash:
          {
            var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");

            if (pipeProposal) {
              node = this.startNode();
              var _start = this.state.start;
              var tokenType = this.state.type;
              this.next();
              return this.finishTopicReference(node, _start, pipeProposal, tokenType);
            }
          }

        case types$1.relational:
          {
            if (this.state.value === "<") {
              var lookaheadCh = this.input.codePointAt(this.nextTokenStart());

              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
              }
            }
          }

        default:
          throw this.unexpected();
      }
    }
  }, {
    key: "finishTopicReference",
    value: function finishTopicReference(node, start, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {
        var nodeType;

        if (pipeProposal === "smart") {
          nodeType = "PipelinePrimaryTopicReference";
        } else {
          nodeType = "TopicReference";
        }

        if (!this.topicReferenceIsAllowedInCurrentContext()) {
          if (pipeProposal === "smart") {
            this.raise(start, ErrorMessages.PrimaryTopicNotAllowed);
          } else {
            this.raise(start, ErrorMessages.PipeTopicUnbound);
          }
        }

        this.registerTopicReference();
        return this.finishNode(node, nodeType);
      } else {
        throw this.raise(start, ErrorMessages.PipeTopicUnconfiguredToken, tokenType.label);
      }
    }
  }, {
    key: "testTopicReferenceConfiguration",
    value: function testTopicReferenceConfiguration(pipeProposal, start, tokenType) {
      switch (pipeProposal) {
        case "hack":
          {
            var pluginTopicToken = this.getPluginOption("pipelineOperator", "topicToken");
            return tokenType.label === pluginTopicToken;
          }

        case "smart":
          return tokenType === types$1.hash;

        default:
          throw this.raise(start, ErrorMessages.PipeTopicRequiresHackPipes);
      }
    }
  }, {
    key: "parseAsyncArrowUnaryFunction",
    value: function parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      var params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types$1.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    }
  }, {
    key: "parseDo",
    value: function parseDo(node, isAsync) {
      this.expectPlugin("doExpressions");

      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }

      node.async = isAsync;
      this.next();
      var oldLabels = this.state.labels;
      this.state.labels = [];

      if (isAsync) {
        this.prodParam.enter(PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }

      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }
  }, {
    key: "parseSuper",
    value: function parseSuper() {
      var node = this.startNode();
      this.next();

      if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, "Super");
    }
  }, {
    key: "parseMaybePrivateName",
    value: function parseMaybePrivateName(isPrivateNameAllowed) {
      var isPrivate = this.match(types$1.privateName);

      if (isPrivate) {
        if (!isPrivateNameAllowed) {
          this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
        }

        return this.parsePrivateName();
      } else {
        return this.parseIdentifier(true);
      }
    }
  }, {
    key: "parsePrivateName",
    value: function parsePrivateName() {
      var node = this.startNode();
      var id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
      var name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    }
  }, {
    key: "parseFunctionOrFunctionSent",
    value: function parseFunctionOrFunctionSent() {
      var node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types$1.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }
  }, {
    key: "parseMetaProperty",
    value: function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    }
  }, {
    key: "parseImportMetaProperty",
    value: function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    }
  }, {
    key: "parseLiteralAtNode",
    value: function parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
  }, {
    key: "parseLiteral",
    value: function parseLiteral(value, type) {
      var node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    }
  }, {
    key: "parseStringLiteral",
    value: function parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
  }, {
    key: "parseNumericLiteral",
    value: function parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
  }, {
    key: "parseBigIntLiteral",
    value: function parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
  }, {
    key: "parseDecimalLiteral",
    value: function parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
  }, {
    key: "parseRegExpLiteral",
    value: function parseRegExpLiteral(value) {
      var node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    }
  }, {
    key: "parseBooleanLiteral",
    value: function parseBooleanLiteral(value) {
      var node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
  }, {
    key: "parseNullLiteral",
    value: function parseNullLiteral() {
      var node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    }
  }, {
    key: "parseParenAndDistinguishExpression",
    value: function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var first = true;
      var spreadStart;
      var optionalCommaStart;

      while (!this.match(types$1.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);

          if (this.match(types$1.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types$1.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }

      var innerEndPos = this.state.lastTokEnd;
      var innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types$1.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        val.end = innerEndPos;
        val.loc.end = innerEndLoc;
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }
  }, {
    key: "shouldParseArrow",
    value: function shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
  }, {
    key: "parseArrow",
    value: function parseArrow(node) {
      if (this.eat(types$1.arrow)) {
        return node;
      }
    }
  }, {
    key: "parseParenItem",
    value: function parseParenItem(node, startPos, startLoc) {
      return node;
    }
  }, {
    key: "parseNewOrNewTarget",
    value: function parseNewOrNewTarget() {
      var node = this.startNode();
      this.next();

      if (this.match(types$1.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
        }

        return metaProp;
      }

      return this.parseNew(node);
    }
  }, {
    key: "parseNew",
    value: function parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types$1.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }
  }, {
    key: "parseNewArguments",
    value: function parseNewArguments(node) {
      if (this.eat(types$1.parenL)) {
        var args = this.parseExprList(types$1.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }
  }, {
    key: "parseTemplateElement",
    value: function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types$1.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }
  }, {
    key: "parseTemplate",
    value: function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }
  }, {
    key: "parseTemplateSubstitution",
    value: function parseTemplateSubstitution() {
      return this.parseExpression();
    }
  }, {
    key: "parseObjectLike",
    value: function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            break;
          }
        }

        var prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    }
  }, {
    key: "maybeAsyncOrAccessorProp",
    value: function maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
    }
  }, {
    key: "parsePropertyDefinition",
    value: function parsePropertyDefinition(isPattern, refExpressionErrors) {
      var decorators = [];

      if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }

        while (this.match(types$1.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var isAccessor = false;
      var startPos;
      var startLoc;

      if (this.match(types$1.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parsePropertyName(prop, false);

      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        var keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(types$1.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;

          if (this.match(types$1.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    }
  }, {
    key: "getGetterSetterExpectedParamCount",
    value: function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
  }, {
    key: "getObjectOrClassMethodParams",
    value: function getObjectOrClassMethodParams(method) {
      return method.params;
    }
  }, {
    key: "checkGetterSetterParams",
    value: function checkGetterSetterParams(method) {
      var _params;

      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var params = this.getObjectOrClassMethodParams(method);
      var start = method.start;

      if (params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }
  }, {
    key: "parseObjectMethod",
    value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types$1.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }
  }, {
    key: "parseObjectProperty",
    value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else if (this.match(types$1.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else {
          prop.value = cloneIdentifier(prop.key);
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
  }, {
    key: "parseObjPropValue",
    value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    }
  }, {
    key: "parsePropertyName",
    value: function parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types$1.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        var type = this.state.type;
        prop.key = type === types$1.num || type === types$1.string || type === types$1.bigint || type === types$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (type !== types$1.privateName) {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }
  }, {
    key: "initFunction",
    value: function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }
  }, {
    key: "parseMethod",
    value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
      var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    }
  }, {
    key: "parseArrayLike",
    value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
  }, {
    key: "parseArrowExpression",
    value: function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      var flags = functionFlags(isAsync, false);

      if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
  }, {
    key: "setArrowFunctionParameters",
    value: function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    }
  }, {
    key: "parseFunctionBodyAndFinish",
    value: function parseFunctionBodyAndFinish(node, type) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }
  }, {
    key: "parseFunctionBody",
    value: function parseFunctionBody(node, allowExpression) {
      var _this51 = this;

      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isExpression = allowExpression && !this.match(types$1.braceL);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this51.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

            _this51.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          var strictModeChanged = !oldStrict && _this51.state.strict;

          _this51.checkParams(node, !_this51.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (_this51.state.strict && node.id) {
            _this51.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    }
  }, {
    key: "isSimpleParamList",
    value: function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    }
  }, {
    key: "checkParams",
    value: function checkParams(node, allowDuplicates, isArrowFunction) {
      var strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var checkClashes = new Set();
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = node.params[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var param = _step10.value;
          this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  }, {
    key: "parseExprList",
    value: function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    }
  }, {
    key: "parseExprListItem",
    value: function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      var elt;

      if (this.match(types$1.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }

        elt = null;
      } else if (this.match(types$1.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types$1.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }

      return elt;
    }
  }, {
    key: "parseIdentifier",
    value: function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
  }, {
    key: "createIdentifier",
    value: function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
  }, {
    key: "parseIdentifierName",
    value: function parseIdentifierName(pos, liberal) {
      var name;
      var _this$state4 = this.state,
          start = _this$state4.start,
          type = _this$state4.type;

      if (type === types$1.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types$1.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    }
  }, {
    key: "checkReservedWord",
    value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }

      if (!canBeReservedWord(word)) {
        return;
      }

      if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else if (this.scope.inStaticBlock) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
        }
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.ArgumentsInClass);
          return;
        }
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    }
  }, {
    key: "isAwaitAllowed",
    value: function isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    }
  }, {
    key: "parseAwait",
    value: function parseAwait(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);

      if (this.eat(types$1.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }

      return this.finishNode(node, "AwaitExpression");
    }
  }, {
    key: "isAmbiguousAwait",
    value: function isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
    }
  }, {
    key: "parseYield",
    value: function parseYield() {
      var node = this.startNode();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
      this.next();
      var delegating = false;
      var argument = null;

      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(types$1.star);

        switch (this.state.type) {
          case types$1.semi:
          case types$1.eof:
          case types$1.braceR:
          case types$1.parenR:
          case types$1.bracketR:
          case types$1.braceBarR:
          case types$1.colon:
          case types$1.comma:
            if (!delegating) break;

          default:
            argument = this.parseMaybeAssign();
        }
      }

      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    }
  }, {
    key: "checkPipelineAtInfixOperator",
    value: function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    }
  }, {
    key: "checkHackPipeBodyEarlyErrors",
    value: function checkHackPipeBodyEarlyErrors(startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, types$1.arrow.label);
      } else if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(startPos, ErrorMessages.PipeTopicUnused);
      }
    }
  }, {
    key: "parseSmartPipelineBodyInStyle",
    value: function parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);

      if (this.isSimpleReference(childExpr)) {
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        this.checkSmartPipeTopicBodyEarlyErrors(startPos);
        bodyNode.expression = childExpr;
        return this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
  }, {
    key: "isSimpleReference",
    value: function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }
  }, {
    key: "checkSmartPipeTopicBodyEarlyErrors",
    value: function checkSmartPipeTopicBodyEarlyErrors(startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(startPos, ErrorMessages.PipelineTopicUnused);
      }
    }
  }, {
    key: "withTopicBindingContext",
    value: function withTopicBindingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: "withSmartMixTopicForbiddingContext",
    value: function withSmartMixTopicForbiddingContext(callback) {
      var proposal = this.getPluginOption("pipelineOperator", "proposal");

      if (proposal === "smart") {
        var outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };

        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
  }, {
    key: "withSoloAwaitPermittingContext",
    value: function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
  }, {
    key: "allowInAnd",
    value: function allowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }
  }, {
    key: "disallowInAnd",
    value: function disallowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }
  }, {
    key: "registerTopicReference",
    value: function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
  }, {
    key: "topicReferenceIsAllowedInCurrentContext",
    value: function topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
  }, {
    key: "topicReferenceWasUsedInCurrentContext",
    value: function topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
  }, {
    key: "parseFSharpPipelineBody",
    value: function parseFSharpPipelineBody(prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
  }, {
    key: "parseModuleExpression",
    value: function parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      var node = this.startNode();
      this.next();
      this.eat(types$1.braceL);
      var revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      var program = this.startNode();

      try {
        node.body = this.parseProgram(program, types$1.braceR, "module");
      } finally {
        revertScopes();
      }

      this.eat(types$1.braceR);
      return this.finishNode(node, "ModuleExpression");
    }
  }]);

  return ExpressionParser;
}(LValParser);

var loopLabel = {
  kind: "loop"
},
    switchLabel = {
  kind: "switch"
};
var FUNC_NO_FLAGS = 0,
    FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var keywordRelationalOperator = new RegExp("in(?:stanceof)?", "y");

function babel7CompatTokens(tokens) {
  {
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (token.type === types$1.privateName) {
        var loc = token.loc,
            start = token.start,
            value = token.value,
            end = token.end;
        var hashEndPos = start + 1;
        var hashEndLoc = new Position(loc.start.line, loc.start.column + 1);
        tokens.splice(i, 1, new Token({
          type: types$1.hash,
          value: "#",
          start: start,
          end: hashEndPos,
          startLoc: loc.start,
          endLoc: hashEndLoc
        }), new Token({
          type: types$1.name,
          value: value,
          start: hashEndPos,
          end: end,
          startLoc: hashEndLoc,
          endLoc: loc.end
        }));
      }
    }
  }
  return tokens;
}

var StatementParser =
/*#__PURE__*/
function (_ExpressionParser) {
  _inherits(StatementParser, _ExpressionParser);

  function StatementParser() {
    _classCallCheck(this, StatementParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(StatementParser).apply(this, arguments));
  }

  _createClass(StatementParser, [{
    key: "parseTopLevel",
    value: function parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);
      return this.finishNode(file, "File");
    }
  }, {
    key: "parseProgram",
    value: function parseProgram(program) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types$1.eof;
      var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.sourceType;
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i3 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i3 < _Array$from2.length; _i3++) {
          var _Array$from2$_i = _slicedToArray(_Array$from2[_i3], 1),
              name = _Array$from2$_i[0];

          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      return this.finishNode(program, "Program");
    }
  }, {
    key: "stmtToDirective",
    value: function stmtToDirective(stmt) {
      var directive = stmt;
      directive.type = "Directive";
      directive.value = directive.expression;
      delete directive.expression;
      var directiveLiteral = directive.value;
      var raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directiveLiteral.type = "DirectiveLiteral";
      return directive;
    }
  }, {
    key: "parseInterpreterDirective",
    value: function parseInterpreterDirective() {
      if (!this.match(types$1.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
  }, {
    key: "isLet",
    value: function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      return this.isLetKeyword(context);
    }
  }, {
    key: "isLetKeyword",
    value: function isLetKeyword(context) {
      var next = this.nextTokenStart();
      var nextCh = this.codePointAtPos(next);

      if (nextCh === 92 || nextCh === 91) {
        return true;
      }

      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        keywordRelationalOperator.lastIndex = next;

        if (keywordRelationalOperator.test(this.input)) {
          var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);

          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }

        return true;
      }

      return false;
    }
  }, {
    key: "parseStatement",
    value: function parseStatement(context, topLevel) {
      if (this.match(types$1.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }
  }, {
    key: "parseStatementContent",
    value: function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }

      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types$1._debugger:
          return this.parseDebuggerStatement(node);

        case types$1._do:
          return this.parseDoStatement(node);

        case types$1._for:
          return this.parseForStatement(node);

        case types$1._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types$1._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types$1._if:
          return this.parseIfStatement(node);

        case types$1._return:
          return this.parseReturnStatement(node);

        case types$1._switch:
          return this.parseSwitchStatement(node);

        case types$1._throw:
          return this.parseThrowStatement(node);

        case types$1._try:
          return this.parseTryStatement(node);

        case types$1._const:
        case types$1._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types$1._while:
          return this.parseWhileStatement(node);

        case types$1._with:
          return this.parseWithStatement(node);

        case types$1.braceL:
          return this.parseBlock();

        case types$1.semi:
          return this.parseEmptyStatement(node);

        case types$1._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }

        case types$1._export:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }

            this.next();
            var result;

            if (starttype === types$1._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }
  }, {
    key: "assertModuleNodeAllowed",
    value: function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
      }
    }
  }, {
    key: "takeDecorators",
    value: function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }
  }, {
    key: "canHaveLeadingDecorator",
    value: function canHaveLeadingDecorator() {
      return this.match(types$1._class);
    }
  }, {
    key: "parseDecorators",
    value: function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types$1.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types$1._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    }
  }, {
    key: "parseDecorator",
    value: function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.eat(types$1.parenL)) {
          expr = this.parseExpression();
          this.expect(types$1.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types$1.dot)) {
            var _node10 = this.startNodeAt(startPos, startLoc);

            _node10.object = expr;
            _node10.property = this.parseIdentifier(true);
            _node10.computed = false;
            expr = this.finishNode(_node10, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }
  }, {
    key: "parseMaybeDecoratorArguments",
    value: function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types$1.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }
  }, {
    key: "parseBreakContinueStatement",
    value: function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
  }, {
    key: "verifyBreakContinue",
    value: function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    }
  }, {
    key: "parseDebuggerStatement",
    value: function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
  }, {
    key: "parseHeaderExpression",
    value: function parseHeaderExpression() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    }
  }, {
    key: "parseDoStatement",
    value: function parseDoStatement(node) {
      var _this52 = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this52.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseHeaderExpression();
      this.eat(types$1.semi);
      return this.finishNode(node, "DoWhileStatement");
    }
  }, {
    key: "parseForStatement",
    value: function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.parenL);

      if (this.match(types$1.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var startsWithLet = this.isContextual("let");
      var isLet = startsWithLet && this.isLetKeyword();

      if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
        var _init = this.startNode();

        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types$1._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);
      var isForOf = this.isContextual("of");

      if (isForOf) {
        if (startsWithLet) {
          this.raise(init.start, ErrorMessages.ForOfLet);
        } else if (awaitAt === -1 && startsWithUnescapedName && init.type === "Identifier" && init.name === "async") {
          this.raise(init.start, ErrorMessages.ForOfAsync);
        }
      }

      if (isForOf || this.match(types$1._in)) {
        this.toAssignable(init, true);
        var description = isForOf ? "for-of statement" : "for-in statement";
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }
  }, {
    key: "parseFunctionStatement",
    value: function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }
  }, {
    key: "parseIfStatement",
    value: function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }
  }, {
    key: "parseReturnStatement",
    value: function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }
  }, {
    key: "parseSwitchStatement",
    value: function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types$1.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(types$1.braceR);) {
        if (this.match(types$1._case) || this.match(types$1._default)) {
          var isCase = this.match(types$1._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types$1.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
  }, {
    key: "parseThrowStatement",
    value: function parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
  }, {
    key: "parseCatchClauseParam",
    value: function parseCatchClauseParam() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, "catch clause", BIND_LEXICAL);
      return param;
    }
  }, {
    key: "parseTryStatement",
    value: function parseTryStatement(node) {
      var _this53 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types$1._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types$1.parenL)) {
          this.expect(types$1.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types$1.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withSmartMixTopicForbiddingContext(function () {
          return _this53.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    }
  }, {
    key: "parseVarStatement",
    value: function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
  }, {
    key: "parseWhileStatement",
    value: function parseWhileStatement(node) {
      var _this54 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this54.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
  }, {
    key: "parseWithStatement",
    value: function parseWithStatement(node) {
      var _this55 = this;

      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this55.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    }
  }, {
    key: "parseEmptyStatement",
    value: function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
  }, {
    key: "parseLabeledStatement",
    value: function parseLabeledStatement(node, maybeName, expr, context) {
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this.state.labels[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var _label = _step11.value;

          if (_label.name === maybeName) {
            this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
          }
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var label = this.state.labels[i];

        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
  }, {
    key: "parseExpressionStatement",
    value: function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
  }, {
    key: "parseBlock",
    value: function parseBlock() {
      var allowDirectives = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var createNewLexicalScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var afterBlockParse = arguments.length > 2 ? arguments[2] : undefined;
      var node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(types$1.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types$1.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }
  }, {
    key: "isValidDirective",
    value: function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
  }, {
    key: "parseBlockBody",
    value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }
  }, {
    key: "parseBlockOrModuleBlockBody",
    value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;

      while (!this.match(end)) {
        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    }
  }, {
    key: "parseFor",
    value: function parseFor(node, init) {
      var _this56 = this;

      node.init = init;
      this.semicolon(false);
      node.test = this.match(types$1.semi) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(types$1.parenR) ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this56.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
  }, {
    key: "parseForIn",
    value: function parseForIn(node, init, awaitAt) {
      var _this57 = this;

      var isForIn = this.match(types$1._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types$1.parenR);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return _this57.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
  }, {
    key: "parseVar",
    value: function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types$1.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) break;
      }

      return node;
    }
  }, {
    key: "parseVarId",
    value: function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
    }
  }, {
    key: "parseFunction",
    value: function parseFunction(node) {
      var _this58 = this;

      var statement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FUNC_NO_FLAGS;
      var isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types$1.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types$1.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withSmartMixTopicForbiddingContext(function () {
        _this58.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
  }, {
    key: "parseFunctionId",
    value: function parseFunctionId(requireId) {
      return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
    }
  }, {
    key: "parseFunctionParams",
    value: function parseFunctionParams(node, allowModifiers) {
      this.expect(types$1.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
      this.expressionScope.exit();
    }
  }, {
    key: "registerFunctionStatementId",
    value: function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }
  }, {
    key: "parseClass",
    value: function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
  }, {
    key: "isClassProperty",
    value: function isClassProperty() {
      return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
    }
  }, {
    key: "isClassMethod",
    value: function isClassMethod() {
      return this.match(types$1.parenL);
    }
  }, {
    key: "isNonstaticConstructor",
    value: function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
    }
  }, {
    key: "parseClassBody",
    value: function parseClassBody(hadSuperClass, oldStrict) {
      var _this59 = this;

      this.classScope.enter();
      var state = {
        hadConstructor: false,
        hadSuperClass: hadSuperClass
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types$1.braceL);
      this.withSmartMixTopicForbiddingContext(function () {
        while (!_this59.match(types$1.braceR)) {
          if (_this59.eat(types$1.semi)) {
            if (decorators.length > 0) {
              throw _this59.raise(_this59.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }

            continue;
          }

          if (_this59.match(types$1.at)) {
            decorators.push(_this59.parseDecorator());
            continue;
          }

          var member = _this59.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this59.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this59.parseClassMember(classBody, member, state);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this59.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
  }, {
    key: "parseClassMemberFromModifier",
    value: function parseClassMemberFromModifier(classBody, member) {
      var key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
  }, {
    key: "parseClassMember",
    value: function parseClassMember(classBody, member, state) {
      var isStatic = this.isContextual("static");

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
  }, {
    key: "parseClassMemberWithIsStatic",
    value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;

      if (this.eat(types$1.star)) {
        method.kind = "method";
        var isPrivateName = this.match(types$1.privateName);
        this.parseClassElementName(method);

        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var isContextual = this.match(types$1.name) && !this.state.containsEsc;
      var isPrivate = this.match(types$1.privateName);
      var key = this.parseClassElementName(member);
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(key.start, ErrorMessages.OverrideOnConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        var isGenerator = this.eat(types$1.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";

        var _isPrivate = this.match(types$1.privateName);

        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (_isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(types$1.star) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = key.name;

        var _isPrivate2 = this.match(types$1.privateName);

        this.parseClassElementName(publicMethod);

        if (_isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
  }, {
    key: "parseClassElementName",
    value: function parseClassElementName(member) {
      var _this$state5 = this.state,
          type = _this$state5.type,
          value = _this$state5.value,
          start = _this$state5.start;

      if ((type === types$1.name || type === types$1.string) && member["static"] && value === "prototype") {
        this.raise(start, ErrorMessages.StaticPrototype);
      }

      if (type === types$1.privateName && value === "constructor") {
        this.raise(start, ErrorMessages.ConstructorClassPrivateField);
      }

      return this.parsePropertyName(member, true);
    }
  }, {
    key: "parseClassStaticBlock",
    value: function parseClassStaticBlock(classBody, member) {
      var _member$decorators;

      this.expectPlugin("classStaticBlock", member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      var oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      var body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, types$1.braceR);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));

      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }
    }
  }, {
    key: "pushClassProperty",
    value: function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    }
  }, {
    key: "pushClassPrivateProperty",
    value: function pushClassPrivateProperty(classBody, prop) {
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    }
  }, {
    key: "pushClassMethod",
    value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
  }, {
    key: "pushClassPrivateMethod",
    value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
    }
  }, {
    key: "parsePostMemberNameModifiers",
    value: function parsePostMemberNameModifiers(methodOrProp) {}
  }, {
    key: "parseClassPrivateProperty",
    value: function parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    }
  }, {
    key: "parseClassProperty",
    value: function parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    }
  }, {
    key: "parseInitializer",
    value: function parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
  }, {
    key: "parseClassId",
    value: function parseClassId(node, isStatement, optionalId) {
      var bindingType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BIND_CLASS;

      if (this.match(types$1.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, "class name", bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    }
  }, {
    key: "parseClassSuper",
    value: function parseClassSuper(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
    }
  }, {
    key: "parseExport",
    value: function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types$1.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types$1.braceL);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types$1._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types$1.braceL);
    }
  }, {
    key: "eatExportStar",
    value: function eatExportStar(node) {
      return this.eat(types$1.star);
    }
  }, {
    key: "maybeParseExportDefaultSpecifier",
    value: function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamespaceSpecifier",
    value: function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportNamedSpecifiers",
    value: function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types$1.braceL)) {
        var _node$specifiers;

        if (!node.specifiers) node.specifiers = [];

        (_node$specifiers = node.specifiers).push.apply(_node$specifiers, _toConsumableArray(this.parseExportSpecifiers()));

        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseExportDeclaration",
    value: function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }
  }, {
    key: "isAsyncFunction",
    value: function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
  }, {
    key: "parseExportDefaultExpression",
    value: function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types$1._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types$1._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        var res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    }
  }, {
    key: "parseExportDeclaration",
    value: function parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
  }, {
    key: "isExportDefaultSpecifier",
    value: function isExportDefaultSpecifier() {
      if (this.match(types$1.name)) {
        var value = this.state.value;

        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }

        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          var l = this.lookahead();

          if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types$1._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      var hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
        return true;
      }

      if (this.match(types$1._default) && hasFrom) {
        var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    }
  }, {
    key: "parseExportFrom",
    value: function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        var assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }
  }, {
    key: "shouldParseExportDeclaration",
    value: function shouldParseExportDeclaration() {
      if (this.match(types$1.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
  }, {
    key: "checkExport",
    value: function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            var declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = node.specifiers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var specifier = _step12.value;
              var exported = specifier.exported;
              var exportedName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportedName);

              if (!isFrom && specifier.local) {
                var local = specifier.local;

                if (local.type !== "Identifier") {
                  this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
                } else {
                  this.checkReservedWord(local.name, local.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                _iterator12["return"]();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = node.declaration.declarations[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var _declaration = _step13.value;
                this.checkDeclaration(_declaration.id);
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                  _iterator13["return"]();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    }
  }, {
    key: "checkDeclaration",
    value: function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = node.properties[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var prop = _step14.value;
            this.checkDeclaration(prop);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
              _iterator14["return"]();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }
      } else if (node.type === "ArrayPattern") {
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = node.elements[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var elem = _step15.value;

            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
              _iterator15["return"]();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
  }, {
    key: "checkDuplicateExports",
    value: function checkDuplicateExports(node, name) {
      if (this.exportedIdentifiers.has(name)) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }

      this.exportedIdentifiers.add(name);
    }
  }, {
    key: "parseExportSpecifiers",
    value: function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        var node = this.startNode();
        var isString = this.match(types$1.string);
        var local = this.parseModuleExportName();
        node.local = local;

        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(local);
        } else {
          node.exported = cloneIdentifier(local);
        }

        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    }
  }, {
    key: "parseModuleExportName",
    value: function parseModuleExportName() {
      if (this.match(types$1.string)) {
        var result = this.parseStringLiteral(this.state.value);
        var surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
        }

        return result;
      }

      return this.parseIdentifier(true);
    }
  }, {
    key: "parseImport",
    value: function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types$1.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types$1.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      var assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
        var attributes = this.maybeParseModuleAttributes();

        if (attributes) {
          node.attributes = attributes;
        }
      }

      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
  }, {
    key: "parseImportSource",
    value: function parseImportSource() {
      if (!this.match(types$1.string)) this.unexpected();
      return this.parseExprAtom();
    }
  }, {
    key: "shouldParseDefaultImport",
    value: function shouldParseDefaultImport(node) {
      return this.match(types$1.name);
    }
  }, {
    key: "parseImportSpecifierLocal",
    value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }
  }, {
    key: "parseAssertEntries",
    value: function parseAssertEntries() {
      var attrs = [];
      var attrNames = new Set();

      do {
        if (this.match(types$1.braceR)) {
          break;
        }

        var node = this.startNode();
        var keyName = this.state.value;

        if (attrNames.has(keyName)) {
          this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
        }

        attrNames.add(keyName);

        if (this.match(types$1.string)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    }
  }, {
    key: "maybeParseModuleAttributes",
    value: function maybeParseModuleAttributes() {
      if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      var attrs = [];
      var attributes = new Set();

      do {
        var node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }

        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }

        attributes.add(node.key.name);
        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    }
  }, {
    key: "maybeParseImportAssertions",
    value: function maybeParseImportAssertions() {
      if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions")) return [];
        return null;
      }

      this.eat(types$1.braceL);
      var attrs = this.parseAssertEntries();
      this.eat(types$1.braceR);
      return attrs;
    }
  }, {
    key: "maybeParseDefaultImportSpecifier",
    value: function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    }
  }, {
    key: "maybeParseStarImportSpecifier",
    value: function maybeParseStarImportSpecifier(node) {
      if (this.match(types$1.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    }
  }, {
    key: "parseNamedImportSpecifiers",
    value: function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types$1.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }

          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }
  }, {
    key: "parseImportSpecifier",
    value: function parseImportSpecifier(node) {
      var specifier = this.startNode();
      var importedIsString = this.match(types$1.string);
      specifier.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        var imported = specifier.imported;

        if (importedIsString) {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
        }

        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = cloneIdentifier(imported);
      }

      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
  }, {
    key: "isThisParam",
    value: function isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }]);

  return StatementParser;
}(ExpressionParser);

var Parser =
/*#__PURE__*/
function (_StatementParser) {
  _inherits(Parser, _StatementParser);

  function Parser(options, input) {
    var _this60;

    _classCallCheck(this, Parser);

    options = getOptions(options);
    _this60 = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this, options, input));
    _this60.options = options;

    _this60.initializeScopes();

    _this60.plugins = pluginsMap(_this60.options.plugins);
    _this60.filename = options.sourceFilename;
    return _this60;
  }

  _createClass(Parser, [{
    key: "getScopeHandler",
    value: function getScopeHandler() {
      return ScopeHandler;
    }
  }, {
    key: "parse",
    value: function parse() {
      this.enterInitialScopes();
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }]);

  return Parser;
}(StatementParser);

function pluginsMap(plugins) {
  var pluginMap = new Map();
  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = plugins[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var plugin = _step16.value;

      var _ref17 = Array.isArray(plugin) ? plugin : [plugin, {}],
          _ref18 = _slicedToArray(_ref17, 2),
          name = _ref18[0],
          options = _ref18[1];

      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
        _iterator16["return"]();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  return pluginMap;
}

function parse(input, options) {
  var _options;

  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      var parser = getParser(options, input);
      var ast = parser.parse();

      if (parser.sawUnambiguousESM) {
        return ast;
      }

      if (parser.ambiguousScriptDifferentAst) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }

      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (_unused2) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}

function parseExpression(input, options) {
  var parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}

function getParser(options, input) {
  var cls = Parser;

  if (options != null && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

var parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  var pluginList = mixinPluginNames.filter(function (name) {
    return hasPlugin(pluginsFromOptions, name);
  });
  var key = pluginList.join("/");
  var cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
      for (var _iterator17 = pluginList[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
        var plugin = _step17.value;
        cls = mixinPlugins[plugin](cls);
      }
    } catch (err) {
      _didIteratorError17 = true;
      _iteratorError17 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
          _iterator17["return"]();
        }
      } finally {
        if (_didIteratorError17) {
          throw _iteratorError17;
        }
      }
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types$1;